# 01장 프로그래밍

+ 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것





# 02장 자바스크립트란?

+ Ajax : 자바스크립트를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신기능
+ Node.js 
  - 구글 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경
  - 브라우저 이외의 환경에서도 동작할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경
  - 주로 서버 사이드 애플리케이션 개발에 사용
  - 데이터를 실시간으로 처리하기 위해 I/O가 빈번하게 발생하는 Single Page Application에 적합
+ SPA프레임 워크 : Angular, React, Vue.js, Svelte
+ 자바스크립트의 특징
  - 웹 브라우저에서 동작하는 유일한 프로그래밍 언어
  - 클래스 기반 객체지향언어보다 효율적이면서 강력한 프로토타입 기반의 객체지향언어
  - 컴파일러 언어 : 실행파일 생성, 컴파일단계와 실행단계가 분리되어 실행속도 빠름, 머신코드 변환
  - 인터프리터 언어 : 인터프리트단계와 실행단계가 분리되어 있지 않고 반복수행되어 실행속도 느림, 중간코드(바이트코드)로 변환
  - 컴파일러언어처럼 명시적인 컴파일 단계를 거치지는 않지만 일부 소스코드를 컴파일하고 실행해 인터프리터 언어의 장점인 동적 기능 지원을 살리면서 실행 속도가 느리다는 단점을 극복







# 03장 자바스크립트 개발 환경과 실행 방법

+ 브라우저 : 클라이언트 사이드 Web API
+ Node.js : Node.js Host API







# 04장 변수

### 4.1 변수란 무엇인가? 왜 필요한가?

+ 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고 저장된 값을 읽어들여 재사용하기 위해 변수라는 메커니즘을 제공
+ 하나의 값을 저장하기 위해 확보한 메모리 공간 자제 또는 그 메모리 공간을 식별하기 위해 붙인 이름
+ 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없고 변수를 통해 안전하게 값에 접근할 수 있다.
+ 개발자의 의도를 나타내는 명확한 네이밍이 필요



### 4.2 식별자

+ 어떤 값을 구별해서 식별할 수 있는 고유한 이름
+ 값이 아닌 메모리 주소를 기억하고 있다.
+ 변수, 함수, 클래스 등의 이름은 모두 식별자
+ 선언에 의해 자바스크립트 엔진에 식별자의 존재를 알림



### 4.3 변수 선언

+ 선언단계 : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알림, 런타임 이전에 먼저 실행

  초기화단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화함 (garbage value 방지)

+ var 
  - 블록레벨스코프가 아닌 함수레벨스코프를 지원 -> 의도치않게 전역변수가 선언되어 부작용이 발생
  - 선언과 초기화가 동시에 진행
  - 값의 재할당이 가능



### 4.4 변수 선언의 실행 시점과 변수 호이스팅

+ 변수 선언이 소스코드가 순차적으로 실행되는 런타임 이전 단계에서 먼저 실행

+ 호이스팅(hoisting) : 모든 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징



### 4.5 값의 할당

+ 이전 값이 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 재할당 값을 저장하는게 아니라 새로운 메모리 공간을 확보하고 그 메모리 공간에 값을 저장
+ 가비지콜렉터 : 메모리 공간을 주기적으로 검사해 더 이상 사용하지 않는 메모리를 해제하는 기능

```javascript
console.log(score); // undefined 변수 선언은 런타임 이전에 실행

var score = 100; // 값의 할당은 런타임에 실행

console.log(score); // 100 값의 재할당
```



### 4.6 식별자 네이밍 규칙

+ 특수문자를 제외한 문자, 숫자, 언더바, 달러기호를 포함할 수 있고 시작해야 한다.
+ 숫자, 예약어 X
+ 대소문자를 구분
+ 의미를 명확히 표현
+ camelCase : 변수, 함수
+ PascalCase : 생성자 함수, 클래스







# 05장 표현식과 문

### 5.1 값

+ 식이 해석되어 생성된 결과

```javascript
10 + 20; // 식이 평가되어 값 30을 생성
```



### 5.2 리터럴

+ 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법
+ 객체리터럴 : { name: 'Kim', address: 'Suwon' }
+ 배열리터럴 : [ 1, 2, 3 ]
+ 함수리터럴 : function() {}



### 5.3 표현식

+ 값으로 평가될 수 있는 문(statement), 표현식이 평가되면 새로운 값을 생성하거나 기존값을 참조

+ 다른 표현식의 일부가 되어 새로운 값을 생성할 수 있다.

  ```javascript
  var x = 1 + 2;
  x + 3; // 6
  ```

+ ```javascript
  'HELLO' // 리터럴 표현식
  person.name // 식별자 표현식
  sum = 10 // 연산자 표현식
  square() // 함수 호출 표현식
  ```

  

### 5.4 문

+ 프로그램을 구성하는 기본 또는 최소 단위 = 명령문

+ 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍

+ ```javascript
  var = x; // 변수 선언문
  x = 5; // 할당문
  function foo () {} // 함수 선언문
  if (x > 1) {} // 조건문
  for (var i=0; i<2; i++) {} // 반복문
  ```

  

### 5.6 표현식인 문과 표현식이 아닌 문

+ 값으로 평가될 수 있는 문 / 값으로 평가될 수 없는 문

+ ```javascript
  var x; // 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아닌 문
  x = 1 + 2; // 값으로 평가될 수 있으므로 표현식이면서 완전한 문
  ```

+ 표현식인 문을 실행하면 평가된 값을 반환
+ 표현식이 아닌 문을 실행하면 undefined







# 06장 데이터 타입

+ 원시타입 : 숫자, 문자, 불리언, undefined, null, 심벌
+ 객체타입 : 객체, 함수, 배열



### 6.1 숫자 타입

+ 64비트 부동소수점 방식, 모든 수를 실수로 처리함
+ 양의 무한대 / 음의 무한대 / NaN(not-a-number)



### 6.2 문자열 타입

+ 0개 이상의 16비트 유니코드 문자 (UTF-16)의 집합으로 전세계 대부분의 문자를 표현할 수 있다.
+ 토큰(키워드나 식별자)과 구분하기 위해 따옴표로 감싼다.
+ 원시타입, 변경 불가능

```javascript
var string
string = '문자열';
string = "문자열";
string = `문자열`;
```



### 6.3 템플릿 리터럴

#### 6.3.1 멀티라인 문자열

+ 일반 문자열 내에서는 줄바꿈이 허용되지 않는다.

+ 백슬래시로 시작하는 이스케이프 시퀀스를 사용 또는 백틱으로 묶기

  ```javascript
  var template = '<ul>\n\t<li><a href="#">HOME</a></li>\n</ul>';
  console.log(template); // HTML문자열
  
  var template = `<ul>
  	<li><a href="#">HOME</a></li>
  </ul>`;
  console.log(template); // 템플릿리터럴 사용
  
  // 둘의 출력 결과는 같다.
  ```

#### 6.3.2 표현식 삽입

+ +연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 그 외의 경우는 덧셈 연산자로 동작

  ```javascript
  var first = 'Seo-young';
  var last = 'Kim';
  
  console.log('My name is ' + first + ' ' + last + '.');
  // 문자열 연결
  
  console.log(`My name is ${first} ${last}.`);
  // 템플릿리터럴 사용
  ```

+ 표현식의 결과가 문자열이 아니더라도 강제로 변환되어 삽입되며 반드시 템플릿리터럴 내에서 사용

  ```javascript
  console.log(`1 + 2 = ${1 + 2}`); // 1 + 2 = 3
  console.log('1 + 2 = ${1 + 2}'); // 1 + 2 = ${1 + 2}
  ```



### 6.4 불리언 타입

+ true / false

  

### 6.5 undefined 타입

+ 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화 할 때 사용하는 값



### 6.6 null 타입

+ 변수에 값이 없다는 것을 의도적으로 명시
+ 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환



### 6.7 심벌 타입

+ 변경 불가능한 원시 타입의 값
+ 객체의 유일한 프로퍼티 값을 만들기 위해 사용



### 6.9 데이터 타입의 필요성

+ 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
+ 값을 참조할 때 한번에 읽어들여야 할 메모리 공간의 크기를 결정하기 위해
+ 메모리에서 읽어들인 2진수를 어떻게 해석할지 결정하기 위해



### 6.10 동적 타이핑

+ 정적 타입 (C, C++, JAVA, 코틀린, 고, 하스켈, 러스트, 스칼라)

  - 변수를 선언할 때 데이터 타입을 사전에 선언해야 한다 -> 명시적 타입 선언

  - 변수에 선언한 타입에 맞는 값만 할당할 수 있다.
  - 컴파일 시점에 타입 체크(데이터 타입에 맞는 값을 할당했는지 검사)를 수행
  - 안정적인 코드의 구현을 통해 런타임 오류를 줄임
+ 동적 타입 (자바스크립트, 파이썬, PHP, 루비, 리스프, 펄)
  - 키워드를 사용해 변수를 선언
  - 어떤 데이터의 값도 자유롭게 할당할 수 있다.
  - 할당에 의해 타입이 결정(타입 추론)된다.
  - 재할당에 의해 변수의 타입은 언제든 동적으로 변할 수 있다.
+ 동적 타입의 구조적인 단점
  - 높은 유연성, 낮은 신뢰성
  - 변수는 필요한 만큼 최소한으로 유지
  - 스코프는 최대한 좁게, 전역 변수는 최대한 사용하지 않는다.
  - 상수를 사용해 값의 변경을 억제
  - 변수 이름은 존재 이유를 파악할 수 있는 적절한 이름으로 지어야 한다.







# 07장 연산자

+ 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수연산 등을 수행해 하나의 값을 만든다.
+ 피연산자는 연산의 대상이 되어야 하므로 값으로 평가할 수 있어야 한다. 

### 7.1 산술 연산자

+ 새로운 숫자 값을 만들고 불가능한 경우 NaN을 반환한다.

+ 이항산술연산자 : 피연산자의 값이 바뀌는 경우는 없고 언제나 새로운 값을 만든다. (+, -, *, /, %)

+ 단항산술연산자

  - ++, -- : 피연산자의 값을 변경하는 암묵적 할당이 이루어진다. 부수효과가 있다.

  ```javascript
  var x = 1;
  x++ // x = x + 1;
  console.log(x); // 2
  x-- // x = x - 1;
  console.log(x); // 1
  ```

  ```javascript
  var x = 5, result;
  
  result = x++; // 선할당 후증가
  console.log(result, x); // 5 6
  
  result = ++x; // 선증가 후할당
  console.log(result, x); // 7 7
  ```

  - +단항연산자, -단항연산자 : 부수효과가 없다.

  ```javascript
  +10; // 10
  +(-10); // -10
  // 피연산자에 아무 효과가 없다. 부수효과가 없다.
  
  -(-10) // 10
  // 부호를 반전한 값을 생성해 반환한다. 부수효과는 없다.
  ```

  - 숫자 타입이 아닌 피연산자에 단항 연산자를 사용하면 숫자 타입으로 변환해 반환한다.

  ```javascript
  var x = '1';
  console.log(x); // "1"
  console.log(+x) // 1 숫자타입으로 변환
  
  x = 'Hello';
  console.log(x); // 'Hello'
  console.log(+x); // 문자열을 숫자로 변환할 수 없으므로 NaN 반환
  ```

+ 문자열연결연산자 : 피연산자 중 하나 이상이 문자열인 경우 문자열연결연산자로 동작

  ```javascript
  '1' + 2; // '12'
  1 + 2; // 3
  1 + true; // 2 (암묵적 타입 변환)
  1 + false; // 1 (암묵적 타입 변환)
  1 + null; // 1 (암묵적 타입 변환)
  1 + undefined // NaN
  ```



### 7.2 할당 연산자

+ 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 부수효과가 있다.

```javascript
var x;
x = 10;
x += 5; // 15
x -= 5; // 10

var str = 'My name is ';
str += 'Kim'; // 'My name is Kim'
```



### 7.3 비교 연산자

+ 좌항과 우항의 피연산자를 비교한 다음 불리언값으로 반환
+ 동등비교(==, !=) : 암묵적 타입 변환을 한다. 예측하기 어려운 결과를 만들어 낸다. 일치비교 연산자를 사용한다.
+ 일치비교(===, !==) : 타입도 값도 같은 경우에 한하여 true 반환

```javascript
5 == '5'; // ture 동등 비교, 암묵적 타입 변환을 통해 타입을 일치
5 === '5'; // false 일치 비교, 타입과 값이 모두 같은 경우

NaN === NaN; // false 자신과 일치하지 않는 유일한 값
Number.isNaN(NaN); // true
```

+ 대소관계비교 : <, >, >=, <=



### 7.4 삼항 조건 연산자

+ 조건식의 평가 결과에 따라 반환할 값을 결정 -> 값으로 평가할 수 있는 표현식인 문

+ 조건식 ? true일때 반환할 값 : false일때 반환할 값 -> 조건에 따라 경우의 수가 2개일 때 사용

+ 조건식의 결과가 불리언 값이 아니면 암묵적 타입 변환으로 변환된다.

  ```javascript
  var x = 2;
  
  var result = x % 2 ? '홀수' : '짝수';
  
  console.log(result); // 짝수, 표현식인 문으로 값처럼 사용할 수 있다.
  ```

+ if...else 문 : 표현식이 아닌 문이기 때문에 값처럼 사용할 수 없다. 조건이 여러개일 때 가독성이 더 좋다.



### 7.5 논리 연산자

+ || (or), && (and) 

  - 단축 평가 (도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략)

  - 2개의 피연산자 중 한쪽으로 평가

  ```javascript
  'Cat' && 'Dog' // "Dog"
  // 첫번째 값이 truthy 일때 두번째 값 반환
  'Cat' || 'Dog' // "Cat"
  // 첫번째 값이 truthy 일때 그대로 첫번째 값 반환
  ```

+ ! (not)



### 7.6 쉼표 연산자

+ 차례대로 피연산자를 평가하고 마지막 피연산자의 결과를 반환

  ```javascript
  var x, y, z;
  
  x = 1, y = 2, z = 3; // 3
  ```



### 7.7 그룹 연산자

+ 연산자 우선순위가 가장 높음



### 7.8 type of 연산자

+ 피연산자의 데이터 타입을 문자열로 반환

+ function = function (나머지는 object)

+ null 값은 object 를 반환 -> 자바스크립트 버그

  ```javascript
  var foo = null;
  foo === null; // true
  // 일치 연산자를 사용할 것!
  ```

  

### 7.9 지수 연산자

+ 좌항의 피연산자를 밑, 우항을 지수로 거듭제곱해 반환

+ 이항 연산자 중에서 우선순위가 가장 높음

  ```javascript
  2 ** 2; // 4
  2 ** 2.5; // 5.656854...
  2 ** 0; // 1
  2 ** -2; // 0.25
  
  -5 ** 2; // SyntaxError
  (-5) ** 2; // 25
  
  var num = 5;
  num **= 2; // 25
  ```



### 7.10 부수 효과

+ 할당연산자(=), 증가/감소연산자(++,--), delete연산자
+ 다른 코드에 영향을 주는 부수 효과







# 08장 제어문

+ 조건에 따라 코드블록을 실행(조건문) 하거나 반복 실행(반복문) 할 때 사용
+ 코드의 실행 순서를 인위적으로 제어할 수 있지만 흐름을 이해하기 어렵게 만들어 가독성을 해치는 단점
+ forEach, map, filter, reduce 등 고차 함수를 사용한 함수형 프로그래밍 기법 사용

### 8.1 블록문

+ 0개 이상의 문을 중괄호로 묶은 것 = 코드블록, 블록
+ 블록문은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문에 세미콜론 붙이지 않음

```javascript
// 블록문
{
	var foo = 10;
}

// 제어문
var x = 1;
if (x < 10) {
	x++;
}
```



### 8.2 조건문

+ 주어진 조건식(불리언 값으로 평가될 수 있는 표현식)의 평가 결과에 따라 코드블록의 실행을 결정

#### 8.2.1 if...else문

+ 조건식의 평가 결과에 따라 실행할 코드블록을 결정
+ 조건식이 불리언 값이 아니면 암묵적 타입 변환으로 강제 변환됨
+ if...else if...else : 조건식을 추가할 때

```javascript
var num = 2;
var kind;

if (num > 0)	kind = '양수';
else if (num < 0) kind = '음수';
else			kind = '영';
console.log(kind); // 양수

var kind = num ? (num > 0 ? '양수' : '음수') : '영';
console.log(kind); // 양수
```

+ 실행해야 할 내용에 따라 삼항조건연산자, if...else문을 선택함

#### 8.2.2 switch문

+ 주어진 표현식을 평가해 그 값과 일치하는 표현식을 갖는 case 문으로 실행흐름을 옮김
+ 논리적 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드블록을 결정할 때 사용
+ 다양한 키워드를 사용해야 하고 폴스루가 발생하는 등 문법이 복잡

```javascript
var month = 11;
var monthName;

switch (month) {
	case 1: monthName = 'JAN';
		break;
		.
		.
		.
	case 12: monthName = 'FEB';
		break;
	default: monthName = 'Invalid month';
}
```



### 8.3 반복문

+ 조건식이 참인 경우 코드블록을 실행, 거짓일 때까지 반복

#### 8.3.1 for문

+ 조건식이 거짓일 때까지 실행, 반복 횟수가 명확할 때 사용

```javascript
for (var i=0; i<2; i++) {
	console.log(i); // 0, 1
}

for (var i=1; i<=6; i++) {
    for (var j=1; j<=6; j++) {
        if (i + j === 6) console.log(`[${i}, ${j}]`); // [1,5] [2,4] [3,3] [4,2] [5,1]
    }
}
```

#### 8.3.2 while문

- 조건식이 참이면 실행, 반복 횟수가 불명확할 때 사용

```javascript
var count = 0;

while (count < 3) {
	console.log(count); // 0, 1, 2
	count++; // 선할당 후증가
}
```

#### 8.3.3 do...while문

+ 코드블록을 먼저 실행하고 조건식을 평가, 무조건 한번 이상 실행된다.

```javascript
var count = 0;

do {
	console.log(count); // 0 1 2
	count++;
} while (count < 3);
```



### 8.4 break문

+ 반복문 또는 switch문의 코드블록을 탈출
+ 그외에서 사용하면 SyntaxError 발생



### 8.5 continue문

+ 반복문의 코드블록 실행을 현 지점에서 중단하고 증감식으로 실행 흐름을 이동시킨다.
+ if문 내에서 실행해야 할 코드가 많다면 continue문을 사용하는게 가독성이 더 좋다.

```javascript
var string = 'Hello World';
var search = 'l';
var count = 0;

for (var i = 0; i < string.length; i++) {
	if (string[i] !== search) continue; // l이 아니면 증감식으로 이동
	count++; // l이면 실행, 코드가 길다면 continue문이 가독성이 더 좋다.
}

console.log(count); // 3
```















