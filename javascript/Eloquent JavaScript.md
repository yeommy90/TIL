# Eloquent JavaScript

## 1부 언어

### 1. 값, 타입, 연산자

#### 숫자

+ 자바스크립트에서는 하나의 숫자 값을 저장하는데 고정된 64개의 비트를 사용한다. 예전에는 8비트나 16비트 그룹을 사용해서 뜻하지 않게 오버플로우가 발생했지만 요즘은 핸드폰조차 메모리가 넘치기 때문에 64비트를 자유롭게 사용할 수 있으며 천문학적인 수를 다루는 경우에만 오버플로우를 염려하면 된다.
+ 비트에는 음수도 포함되며 한 비트는 숫자의 부호를 나타낸다. 또 다른 일부는 정수가 아닌 소수점의 위치를  저장하는데 사용된다. 실제로 저장할 수 있는 최대 정수의 수는 9000조 범위 이상이며 아주 크다.
+ 분수의 계산은 파이가 10진수의 유한수로 정확하게 표현될 수 없듯 64비트만 저장할 수 있는 경우에는 숫자의 정밀도가 많이 떨어진다. 중요한 점은 이러한 문제를 인식하고 분수 디지털 숫자를 정확한 값이 아닌 근사치로 취급하라는 것이다.

+ 연산자의 우선 순위 규칙은 주의할 사항이 아니다. 정확하지 않으면 괄호를 추가하면 된다.

#### 문자열

#### 단항 연산자

+ typeof 는 주어진 값의 타입 이름을 문자열 값으로 만든다.

```javascript
console.log(typeof 4.5); // number
console.log(typeof "x"); // string
```

#### 불리언 값

+ 자바스크립트에는 자신과 스스로 비교해도 같지 않은 값이 있다. NaN는 무의미한 계산의 결과를 나타낸다.

```javascript
console.log(NaN == NaN); // false
```

+ 논리합 || 연산자는 주어진 값의 어느 하나가 true면 true
+ 논리곱 && 연산자는 주어진 값이 모두 true면 true

#### 빈 값

+ 의미 있는 값이 없을을 표현한다. 그 자체가 값이지만 아무런 정보를 갖지 않는다.

#### 자동 형 변환

+ 자바스크립트는 연산자를 잘못된 타입의 값에 적용하면 해당 값을 자신이 원하거나 기대한 것과는 다른 방식을 통해 내부적으로 필요한 타입으로 강제로 변환한다.

```javascript
console.log(8 * null); // 0
console.log("5" - 1); // 4
console.log("5" + 1); // 51
console.log("five" * 2); // NaN
console.log(false == 0); // true
```

+ 하지만 연산자의 어느 한쪽에서 null이나 undefined가 발생하면, 양쪽 모두 null이나 undefined인 경우에만 true가 된다.

```javascript
console.log(null == undefined); // true
console.log(null == 0); // false
```

+ || 연산자는 왼쪽 값이 true이면 해당 값을 반환하고 그렇지 않으면 오른쪽 값을 반환한다.
+ && 연산자는 왼쪽 값이 false이면 해당 값을 반환하고 그렇지 않으면 오른쪽 값을 반환한다.
+ Short-circuit Evaluation : 필요할 때만 오른쪽 부분을 평가하는 연산자로, 끔찍한 동작을 하는 프로그램이라 하더라도 ||는 true || X 일 때, &&은 false && X 일 때 언제나 X는 평가되지 않는다.

```javascript
console.log(null || "user"); // user
console.log("agnes" || "user"); // agnes
```

<br>

### 2. 프로그램 구조

#### 표현식과 구문

+ 값을 생성하는 코드 조각을 표현식, 표현식이 모여 전체 문장이 되면 구문, 하나의 프로그램은 구문의 목록으로 구성된다.
+ 경우에 따라 자바스크립트에서는 구문 끝에 세미콜론을 생략할 수 있다. 세미콜론을 안전하게 생략할 수 있는 규칙은 다소 복잡하고 오류가 발생하기 쉽기 때문에 더 많이 알기 전까지는 세미콜론을 생략하지 않는다.

#### 바인딩

+ 자바스크립트에서는 값을 잡아 두기 위해 바인딩 또는 변수라는 것을 제공한다.
+ 데이터를 이름으로 저장하기 위해 사용한다.
+ 바인딩은 여러 가지 값을 담지는 않지만 그러한 값을 움켜쥐고 있다. 무언가를 기억해야 한다면 그 내용을 붙잡기 위한 촉수를 키우거나 기존에 있는 촉수 중 하나를 옮겨 붙이면 된다.

```javascript
let caught = 5 * 5;
// 키워드 let은 이 구문이 바인딩을 정의한다는 것을 나타낸다.
```

#### 함수

+ 함수는 값으로 둘러싸인 작은 프로그램이며 함수를 실행하는 것을 "불러온다", "호출한다", "적용한다" 등으로 표현할 수 있다.
+ 함수에서 값을 만들어낼 때 해당 값을 반환(return)한다고 한다.

#### 제어 흐름

+ 프로그램에 둘 이상의 구문이 있는 경우 구문은 하나의 이야기처럼 위에서 아래로 실행된다. 아래의 조건문, 반복문을 사용하면 제어 흐름을 바꿀 수 있다.
+ 조건부 실행 : 프로그램에 당시의 상황에 따라 적절하게 분기하는 분기 도로가 필요할 때 -> if문
+ 반복 실행 : 코드 조각을 여러 번 실행하는 방법 -> while문, do~while문, for문
  - 대부분의 for문은 while문으로 작성한 구문의 구조보다 더 짧고 명확하다.
+ 분기 실행 : 분기에 사용되는 자바스크립트 구문은 C/Java 계열 프로그래밍 언어를 계승했기 때문에 약간 어색하며 if문을 연결하는 편이 더 나을 수 있다. -> switch문

































