# Eloquent JavaScript

## 1부 언어

### 1. 값, 타입, 연산자

#### 숫자

+ 자바스크립트에서는 하나의 숫자 값을 저장하는데 고정된 64개의 비트를 사용한다. 예전에는 8비트나 16비트 그룹을 사용해서 뜻하지 않게 오버플로우가 발생했지만 요즘은 핸드폰조차 메모리가 넘치기 때문에 64비트를 자유롭게 사용할 수 있으며 천문학적인 수를 다루는 경우에만 오버플로우를 염려하면 된다.
+ 비트에는 음수도 포함되며 한 비트는 숫자의 부호를 나타낸다. 또 다른 일부는 정수가 아닌 소수점의 위치를  저장하는데 사용된다. 실제로 저장할 수 있는 최대 정수의 수는 9000조 범위 이상이며 아주 크다.
+ 분수의 계산은 파이가 10진수의 유한수로 정확하게 표현될 수 없듯 64비트만 저장할 수 있는 경우에는 숫자의 정밀도가 많이 떨어진다. 중요한 점은 이러한 문제를 인식하고 분수 디지털 숫자를 정확한 값이 아닌 근사치로 취급하라는 것이다.

+ 연산자의 우선 순위 규칙은 주의할 사항이 아니다. 정확하지 않으면 괄호를 추가하면 된다.

#### 문자열

#### 단항 연산자

+ typeof 는 주어진 값의 타입 이름을 문자열 값으로 만든다.

```javascript
console.log(typeof 4.5); // number
console.log(typeof "x"); // string
```

#### 불리언 값

+ 자바스크립트에는 자신과 스스로 비교해도 같지 않은 값이 있다. NaN는 무의미한 계산의 결과를 나타낸다.

```javascript
console.log(NaN == NaN); // false
```

+ 논리합 || 연산자는 주어진 값의 어느 하나가 true면 true
+ 논리곱 && 연산자는 주어진 값이 모두 true면 true

#### 빈 값

+ 의미 있는 값이 없을을 표현한다. 그 자체가 값이지만 아무런 정보를 갖지 않는다.

#### 자동 형 변환

+ 자바스크립트는 연산자를 잘못된 타입의 값에 적용하면 해당 값을 자신이 원하거나 기대한 것과는 다른 방식을 통해 내부적으로 필요한 타입으로 강제로 변환한다.

```javascript
console.log(8 * null); // 0
console.log("5" - 1); // 4
console.log("5" + 1); // 51
console.log("five" * 2); // NaN
console.log(false == 0); // true
```

+ 하지만 연산자의 어느 한쪽에서 null이나 undefined가 발생하면, 양쪽 모두 null이나 undefined인 경우에만 true가 된다.

```javascript
console.log(null == undefined); // true
console.log(null == 0); // false
```

+ || 연산자는 왼쪽 값이 true이면 해당 값을 반환하고 그렇지 않으면 오른쪽 값을 반환한다.
+ && 연산자는 왼쪽 값이 false이면 해당 값을 반환하고 그렇지 않으면 오른쪽 값을 반환한다.
+ Short-circuit Evaluation : 필요할 때만 오른쪽 부분을 평가하는 연산자로, 끔찍한 동작을 하는 프로그램이라 하더라도 ||는 true || X 일 때, &&은 false && X 일 때 언제나 X는 평가되지 않는다.

```javascript
console.log(null || "user"); // user
console.log("agnes" || "user"); // agnes
```

<br>

### 2. 프로그램 구조

#### 표현식과 구문

+ 값을 생성하는 코드 조각을 표현식, 표현식이 모여 전체 문장이 되면 구문, 하나의 프로그램은 구문의 목록으로 구성된다.
+ 경우에 따라 자바스크립트에서는 구문 끝에 세미콜론을 생략할 수 있다. 세미콜론을 안전하게 생략할 수 있는 규칙은 다소 복잡하고 오류가 발생하기 쉽기 때문에 더 많이 알기 전까지는 세미콜론을 생략하지 않는다.

#### 바인딩

+ 자바스크립트에서는 값을 잡아 두기 위해 바인딩 또는 변수라는 것을 제공한다.
+ 데이터를 이름으로 저장하기 위해 사용한다.
+ 바인딩은 여러 가지 값을 담지는 않지만 그러한 값을 움켜쥐고 있다. 무언가를 기억해야 한다면 그 내용을 붙잡기 위한 촉수를 키우거나 기존에 있는 촉수 중 하나를 옮겨 붙이면 된다.

```javascript
let caught = 5 * 5;
// 키워드 let은 이 구문이 바인딩을 정의한다는 것을 나타낸다.
```

#### 함수

+ 함수는 값으로 둘러싸인 작은 프로그램이며 함수를 실행하는 것을 "불러온다", "호출한다", "적용한다" 등으로 표현할 수 있다.
+ 함수에서 값을 만들어낼 때 해당 값을 반환(return)한다고 한다.

#### 제어 흐름

+ 프로그램에 둘 이상의 구문이 있는 경우 구문은 하나의 이야기처럼 위에서 아래로 실행된다. 아래의 조건문, 반복문을 사용하면 제어 흐름을 바꿀 수 있다.
+ 조건부 실행 : 프로그램에 당시의 상황에 따라 적절하게 분기하는 분기 도로가 필요할 때 -> if문
+ 반복 실행 : 코드 조각을 여러 번 실행하는 방법 -> while문, do~while문, for문
  - 대부분의 for문은 while문으로 작성한 구문의 구조보다 더 짧고 명확하다.
+ 분기 실행 : 분기에 사용되는 자바스크립트 구문은 C/Java 계열 프로그래밍 언어를 계승했기 때문에 약간 어색하며 if문을 연결하는 편이 더 나을 수 있다. -> switch문

<br>

### 3. 함수

+ 가장 명확한 함수의 쓰임새는 새로운 어휘를 만드는 것이다. 일반적으로 글을 쓸 때는 새로운 어휘를 만드는 것은 좋지 않지만 프로그래밍에서는 필수적이다. 반복을 줄일 수 있는 새로운 개념을 도입해야 한다.

#### 함수 정의

+ 함수는 function 키워드로 시작하는 표현식이다.
+ 값을 생성하는 함수도 있고 실행 결과 값만 생성하는 함수도 있다. return 구문은 함수에서 반환되는 값을 결정하는데 제어문에서 이 구문을 만나면 즉시 현재 함수에서 빠져나와 함수를 호출한 코드에 반환된 값을 전달한다.

```javascript
const makeNoise = function() {
	console.log("Pling!");
};
makeNoise(); // Pling! 실행 결과 값만 생성한다.

const power = function(base, exponent) {
	let result = 1;
	for (let count = 0; count < exponent; count++) {
		result *= base;
	}
	return result;
};
console.log(power(2, 10)); // 1024 값을 생성한다.
```

#### 바인딩과 범위

+ scope는 바인딩을 식별할 수 있는 프로그램의 영역을 말한다. 함수나 블록 외부에서 정의한 바인딩의 경우 그 범위는 프로그램 전체이며 이 바인딩은 어디서든지 참조할 수 있다 -> global scope
+ let과 const로 선언한 바인딩은 실제로 바인딩이 선언된 블록까지가 지역 범위이므로 반복문 내부의 코드에서 선언하게 되면 해당 반복문 앞뒤의 코드에서는 이 바인딩을 식별할 수 없다.
+ var 키워드로 생성한 과거 스타일의 바인딩은 함수에서만 새 범위를 만들었기 때문에 해당 바인딩이 내부에 포함된 경우 함수 내부에서 식별되고 함수 내부에 없는 경우라면 전역 범위에서 식별된다.
+ 렉시컬 스코핑 : 블록 내부에 있는 바인딩의 가시성은 해당 블록이 프로그램에서 어느 위치에 있느냐에 따라 결정된다. 

#### 함수 값

#### 선언 표기법

+ 함수 선언문 : function 키워드를 구문 시작 위치에 사용하는 방식이며 동작 방식이 다르다.
+ 함수 선언문으로 선언된 함수는 사용하는 코드의 아래쪽에 해당 함수가 위치해 있어도 함수 선언은 호이스팅되어 범위의 맨 위로 옮겨지고 해당 범위의 모든 코드에서 사용할 수 있다.

#### 화살표 함수

+ 화살표 함수는 함수 표현식을 장황하지 않으면서 간결하게 작성할 수 있다.

#### 호출 스택

+ 함수가 반환될 때 함수를 반환한 후 호출한 곳으로 돌아가야하기 때문에 컴퓨터는 호출이 발생한 컨텍스트를 기억해야 한다. 함수가 호출될 때마다 현재 컨텍스트가 이 스택의 맨 위에 저장된다. 함수가 반환되면 스택에서 최상위 컨텍스트를 꺼낸 후 해당 컨텍스트를 실행한다. (FIFO)

#### 선택적 인수

+ 하나의 매개변수를 갖는 함수를 정의했을 때, 세 개의 매개변수를 전달한다면? 오류가 발생하지 않고 추가로 전달한 인수를 무시하고 첫번째 인수만을 사용한다. 반대로 매개변수가 부족하면 누락된 매개변수에 undefined 값을 할당한다.
+ 실수로 잘못된 개수의 인수를 전달할 위험이 있지만, 다양한 개수의 인수로 같은 함수를 호출할 수 있다는 장점이 있다.

```javascript
function minus(a, b) {
	if(b===undefined) return -a;
	else return a - b;
}

console.log(minus(10)); // -10
console.log(minus(10, 5)); // 5
```

+ 매개변수에 기본값을 설정할 수 있다.

#### 클로저

+ 함수를 호출하면 함수 본문은 호출된 시점의 환경이 아닌 생성된 시점의 환경을 참조한다.
+ 외부 범위의 지역 바인딩 인스턴스를 참조할 수 있는 기능을 클로저라고 하고, 함수 주변의 지역 범위에서 바인딩을 참조하는 함수를 클로저라고 한다.



























