# 01장 프로그래밍

+ 0과 1밖에 알지 못하는 기계가 실행할 수 있을 정도로 정확하고 상세하게 요구사항을 설명하는 작업 -> 코드
+ 프로그래밍 언어가 제공하는 문법을 적절히 사용해 변수를 통해 값을 저장하고 참조하며, 연산자로 값을 연산, 평가하고 조건문과 반복문에 의한 흐름제어로 코드의 실행 순서를 제어하고 함수로 재사용 가능한 문의 집합을 만들며 객체, 배열 등으로 자료를 구조화한다.
+ 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것

<br>

<br>

# 02장 자바스크립트란?

+ Ajax : 자바스크립트를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신기능

  웹페이지에서 변경할 필요가 없는 부분은 다시 렌더링하지 않고 서버로부터 필요한 데이터만 전송받아 필요한 부분만 렌더링하는 방식

+ Node.js 
  - 구글 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경
  - 브라우저 이외의 환경에서도 동작할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경
  - 주로 서버 사이드 애플리케이션 개발에 사용
  - 데이터를 실시간으로 처리하기 위해 I/O가 빈번하게 발생하는 Single Page Application에 적합
  
+ SPA프레임 워크 : Angular, React, Vue.js, Svelte

+ 자바스크립트의 특징
  - 웹 브라우저에서 동작하는 유일한 프로그래밍 언어
  - 클래스 기반 객체지향언어보다 효율적이면서 강력한 프로토타입 기반의 객체지향언어
  - 컴파일러 언어 : 실행파일 생성, 컴파일단계와 실행단계가 분리되어 실행속도 빠름, 머신코드 변환
  - 인터프리터 언어 : 인터프리트단계와 실행단계가 분리되어 있지 않고 반복수행되어 실행속도 느림, 중간코드(바이트코드)로 변환
  - 컴파일러언어처럼 명시적인 컴파일 단계를 거치지는 않지만 일부 소스코드를 컴파일하고 실행해 인터프리터 언어의 장점인 동적 기능 지원을 살리면서 실행 속도가 느리다는 단점을 극복

<br>

<br>

# 03장 자바스크립트 개발 환경과 실행 방법

+ 브라우저 : 클라이언트 사이드 Web API
+ Node.js : Node.js Host API

<br>

<br>

# 04장 변수

### 4.1 변수란 무엇인가? 왜 필요한가?

+ 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고 저장된 값을 읽어들여 재사용하기 위해 변수라는 메커니즘을 제공
+ 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
+ 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없고 변수를 통해 안전하게 값에 접근할 수 있다.
+ 개발자의 의도를 나타내는 명확한 네이밍이 필요
+ 변수에 값을 저장하는 것이 할당, 저장된 값을 읽어들이는 것을 참조

<br>

### 4.2 식별자

+ 어떤 값을 구별해서 식별할 수 있는 고유한 이름
+ 값이 아닌 메모리 주소를 기억하고 있다.
+ 변수, 함수, 클래스 등의 이름은 모두 식별자
+ 선언에 의해 자바스크립트 엔진에 식별자의 존재를 알림

<br>

### 4.3 변수 선언

+ 선언단계 : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알림, 런타임 이전에 먼저 실행

  초기화단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화함 (garbage value 방지)

+ var 
  - 블록레벨스코프가 아닌 함수레벨스코프를 지원 -> 의도치않게 전역변수가 선언되어 부작용이 발생
  - 선언과 초기화가 동시에 진행
  - 값의 재할당이 가능

<br>

### 4.4 변수 선언의 실행 시점과 변수 호이스팅

+ 변수 선언이 소스코드가 순차적으로 실행되는 런타임 이전 단계에서 먼저 실행

+ 호이스팅(hoisting) : 모든 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

<br>

### 4.5 값의 할당

+ 이전 값이 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 재할당 값을 저장하는게 아니라 새로운 메모리 공간을 확보하고 그 메모리 공간에 값을 저장
+ 가비지콜렉터 : 메모리 공간을 주기적으로 검사해 더 이상 사용하지 않는 메모리를 해제하는 기능

```javascript
console.log(score); // undefined 변수 선언은 런타임 이전에 실행

var score = 100; // 값의 할당은 런타임에 실행

console.log(score); // 100 값의 재할당
```

<br>

### 4.6 식별자 네이밍 규칙

+ 특수문자를 제외한 문자, 숫자, 언더바, 달러기호를 포함할 수 있다.
+ 문자, 언더바, 달러기호로 시작해야 한다.
+ 숫자, 예약어 X
+ 대소문자를 구분
+ 의미를 명확히 표현
+ camelCase : 변수, 함수
+ PascalCase : 생성자 함수, 클래스

<br>

<br>

# 05장 표현식과 문

### 5.1 값

+ 식이 해석되어 생성된 결과

```javascript
10 + 20; // 식이 평가되어 값 30을 생성
```

<br>

### 5.2 리터럴

+ 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법
+ 객체리터럴 : { name: 'Kim', address: 'Suwon' }
+ 배열리터럴 : [ 1, 2, 3 ]
+ 함수리터럴 : function() {}

<br>

### 5.3 표현식

+ 값으로 평가될 수 있는 문(statement), 표현식이 평가되면 새로운 값을 생성하거나 기존값을 참조

+ 다른 표현식의 일부가 되어 새로운 값을 생성할 수 있다.

  ```javascript
  var x = 1 + 2;
  x + 3; // 6
  ```

+ ```javascript
  'HELLO' // 리터럴 표현식
  person.name // 식별자 표현식
  sum = 10 // 연산자 표현식
  square() // 함수 호출 표현식
  ```


<br>

### 5.4 문

+ 프로그램을 구성하는 기본 또는 최소 단위 = 명령문

+ 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍

+ ```javascript
  var = x; // 변수 선언문
  x = 5; // 할당문
  function foo () {} // 함수 선언문
  if (x > 1) {} // 조건문
  for (var i=0; i<2; i++) {} // 반복문
  ```


<br>

### 5.6 표현식인 문과 표현식이 아닌 문

+ 값으로 평가될 수 있는 문 / 값으로 평가될 수 없는 문

+ ```javascript
  var x; // 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아닌 문
  x = 1 + 2; // 값으로 평가될 수 있으므로 표현식이면서 완전한 문
  ```

+ 표현식인 문을 실행하면 평가된 값을 반환
+ 표현식이 아닌 문을 실행하면 undefined

<br>

<br>

# 06장 데이터 타입

+ 원시타입 : 숫자, 문자, 불리언, undefined, null, 심벌
+ 객체타입 : 객체, 함수, 배열

### 6.1 숫자 타입

+ 64비트 부동소수점 방식, 모든 수를 실수로 처리함
+ 양의 무한대 / 음의 무한대 / NaN(not-a-number)

<br>

### 6.2 문자열 타입

+ 0개 이상의 16비트 유니코드 문자 (UTF-16)의 집합으로 전세계 대부분의 문자를 표현할 수 있다.
+ 토큰(키워드나 식별자)과 구분하기 위해 따옴표로 감싼다.
+ 원시타입, 변경 불가능

```javascript
var string
string = '문자열';
string = "문자열";
string = `문자열`;
```

<br>

### 6.3 템플릿 리터럴

#### 6.3.1 멀티라인 문자열

+ 일반 문자열 내에서는 줄바꿈이 허용되지 않는다.

+ 백슬래시로 시작하는 이스케이프 시퀀스를 사용 또는 백틱으로 묶기

  ```javascript
  var template = '<ul>\n\t<li><a href="#">HOME</a></li>\n</ul>';
  console.log(template); // HTML문자열
  
  var template = `<ul>
  	<li><a href="#">HOME</a></li>
  </ul>`;
  console.log(template); // 템플릿리터럴 사용
  
  // 둘의 출력 결과는 같다.
  ```

#### 6.3.2 표현식 삽입

+ +연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 그 외의 경우는 덧셈 연산자로 동작

  ```javascript
  var first = 'Seo-young';
  var last = 'Kim';
  
  console.log('My name is ' + first + ' ' + last + '.');
  // 문자열 연결
  
  console.log(`My name is ${first} ${last}.`);
  // 템플릿리터럴 사용
  ```

+ 표현식의 결과가 문자열이 아니더라도 강제로 변환되어 삽입되며 반드시 템플릿리터럴 내에서 사용

  ```javascript
  console.log(`1 + 2 = ${1 + 2}`); // 1 + 2 = 3
  console.log('1 + 2 = ${1 + 2}'); // 1 + 2 = ${1 + 2}
  ```

<br>

### 6.4 불리언 타입

+ true / false


<br>

### 6.5 undefined 타입

+ 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화 할 때 사용하는 값

<br>

### 6.6 null 타입

+ 변수에 값이 없다는 것을 의도적으로 명시
+ 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환

<br>

### 6.7 심벌 타입

+ 변경 불가능한 원시 타입의 값
+ 객체의 유일한 프로퍼티 값을 만들기 위해 사용

<br>

### 6.9 데이터 타입의 필요성

+ 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
+ 값을 참조할 때 한번에 읽어들여야 할 메모리 공간의 크기를 결정하기 위해
+ 메모리에서 읽어들인 2진수를 어떻게 해석할지 결정하기 위해

<br>

### 6.10 동적 타이핑

+ 정적 타입 (C, C++, JAVA, 코틀린, 고, 하스켈, 러스트, 스칼라)

  - 변수를 선언할 때 데이터 타입을 사전에 선언해야 한다 -> 명시적 타입 선언

  - 변수에 선언한 타입에 맞는 값만 할당할 수 있다.
  - 컴파일 시점에 타입 체크(데이터 타입에 맞는 값을 할당했는지 검사)를 수행
  - 안정적인 코드의 구현을 통해 런타임 오류를 줄임
+ 동적 타입 (자바스크립트, 파이썬, PHP, 루비, 리스프, 펄)
  - 키워드를 사용해 변수를 선언
  - 어떤 데이터의 값도 자유롭게 할당할 수 있다.
  - 할당에 의해 타입이 결정(타입 추론)된다.
  - 재할당에 의해 변수의 타입은 언제든 동적으로 변할 수 있다.
+ 동적 타입의 구조적인 단점
  - 높은 유연성, 낮은 신뢰성
  - 변수는 필요한 만큼 최소한으로 유지
  - 스코프는 최대한 좁게, 전역 변수는 최대한 사용하지 않는다.
  - 상수를 사용해 값의 변경을 억제
  - 변수 이름은 존재 이유를 파악할 수 있는 적절한 이름으로 지어야 한다.

<br>

<br>

# 07장 연산자

+ 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수연산 등을 수행해 하나의 값을 만든다.
+ 피연산자는 연산의 대상이 되어야 하므로 값으로 평가할 수 있어야 한다. 

### 7.1 산술 연산자

+ 새로운 숫자 값을 만들고 불가능한 경우 NaN을 반환한다.

+ 이항 산술 연산자 : 피연산자의 값이 바뀌는 경우는 없고 언제나 새로운 값을 만든다. (+, -, *, /, %)

+ 단항 산술 연산자

  - ++, -- : 피연산자의 값을 변경하는 암묵적 할당이 이루어진다. 부수효과가 있다.

  ```javascript
  var x = 1;
  x++ // x = x + 1;
  console.log(x); // 2
  x-- // x = x - 1;
  console.log(x); // 1
  ```

  ```javascript
  var x = 5, result;
  
  result = x++; // 선할당 후증가
  console.log(result, x); // 5 6
  
  result = ++x; // 선증가 후할당
  console.log(result, x); // 7 7
  ```

  - +단항 연산자, -단항 연산자 : 부수효과가 없다.

  ```javascript
  +10; // 10
  +(-10); // -10
  // 피연산자에 아무 효과가 없다. 부수효과가 없다.
  
  -(-10) // 10
  // 부호를 반전한 값을 생성해 반환한다. 부수효과는 없다.
  ```

  - 숫자 타입이 아닌 피연산자에 단항 연산자를 사용하면 숫자 타입으로 변환해 반환한다.

  ```javascript
  var x = '1';
  console.log(x); // "1"
  console.log(+x) // 1 숫자타입으로 변환
  
  x = 'Hello';
  console.log(x); // 'Hello'
  console.log(+x); // 문자열을 숫자로 변환할 수 없으므로 NaN 반환
  ```

+ 문자열 연결 연산자 : 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작

  ```javascript
  '1' + 2; // '12'
  1 + 2; // 3
  1 + true; // 2 (암묵적 타입 변환)
  1 + false; // 1 (암묵적 타입 변환)
  1 + null; // 1 (암묵적 타입 변환)
  1 + undefined // NaN
  ```

<br>

### 7.2 할당 연산자

+ 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 부수효과가 있다.

```javascript
var x;
x = 10;
x += 5; // 15
x -= 5; // 10

var str = 'My name is ';
str += 'Kim'; // 'My name is Kim'
```

<br>

### 7.3 비교 연산자

+ 좌항과 우항의 피연산자를 비교한 다음 불리언값으로 반환
+ 동등비교(==, !=) : 암묵적 타입 변환을 한다. 예측하기 어려운 결과를 만들어 낸다.
+ 일치비교(===, !==) : 타입도 값도 같은 경우에 한해 true 반환

```javascript
5 == '5'; // ture 동등 비교, 암묵적 타입 변환을 통해 타입을 일치
5 === '5'; // false 일치 비교, 타입과 값이 모두 같은 경우

NaN === NaN; // false 자신과 일치하지 않는 유일한 값
Number.isNaN(NaN); // true
```

+ 대소관계비교 : <, >, >=, <=

<br>

### 7.4 삼항 조건 연산자

+ 조건식의 평가 결과에 따라 반환할 값을 결정 -> 값으로 평가할 수 있는 표현식인 문

+ 조건식 ? true일때 반환할 값 : false일때 반환할 값 -> 조건에 따라 경우의 수가 적을 때 사용

+ 조건식의 결과가 불리언 값이 아니면 암묵적 타입 변환으로 변환된다.

  ```javascript
  var x = 2;
  
  var result = x % 2 ? '홀수' : '짝수';
  
  console.log(result); // 짝수, 표현식인 문으로 값처럼 사용할 수 있다.
  ```

+ if...else 문 : 표현식이 아닌 문이기 때문에 값처럼 사용할 수 없다. 조건이 여러개일 때 가독성이 더 좋다.

<br>

### 7.5 논리 연산자

+ || (or), && (and) 

  - 단축 평가 (도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략)

  - 2개의 피연산자 중 한쪽으로 평가

  ```javascript
  'Cat' && 'Dog' // "Dog"
  // 첫번째 값이 truthy 일때 두번째 값 반환
  'Cat' || 'Dog' // "Cat"
  // 첫번째 값이 truthy 일때 그대로 첫번째 값 반환
  ```

+ ! (not)

<br>

### 7.6 쉼표 연산자

+ 차례대로 피연산자를 평가하고 마지막 피연산자의 결과를 반환

  ```javascript
  var x, y, z;
  
  x = 1, y = 2, z = 3; // 3
  ```

<br>

### 7.7 그룹 연산자

+ 연산자 우선순위가 가장 높음

<br>

### 7.8 type of 연산자

+ 피연산자의 데이터 타입을 문자열로 반환

+ function = function (나머지는 object)

+ null 값은 object 를 반환 -> 자바스크립트 버그

  ```javascript
  var foo = null;
  foo === null; // true
  // 일치 연산자를 사용할 것!
  ```


<br>

### 7.9 지수 연산자

+ 좌항의 피연산자를 밑, 우항을 지수로 거듭제곱해 반환

+ 이항 연산자 중에서 우선순위가 가장 높음

  ```javascript
  2 ** 2; // 4
  2 ** 2.5; // 5.656854...
  2 ** 0; // 1
  2 ** -2; // 0.25
  
  -5 ** 2; // SyntaxError
  (-5) ** 2; // 25
  
  var num = 5;
  num **= 2; // 25
  ```

<br>

### 7.10 부수 효과

+ 할당연산자(=,+=,-=), 증가/감소연산자(++,--), delete연산자
+ 다른 코드에 영향을 주는 부수 효과

<br>

<br>

# 08장 제어문

+ 조건에 따라 코드블록을 실행(조건문) 하거나 반복 실행(반복문) 할 때 사용

+ 코드의 실행 순서를 인위적으로 제어할 수 있지만 흐름을 이해하기 어렵게 만들어 가독성을 해치는 단점

  -> forEach, map, filter, reduce 등 고차 함수를 사용한 함수형 프로그래밍 기법 사용

### 8.1 블록문

+ 0개 이상의 문을 중괄호로 묶은 것 = 코드블록, 블록
+ 블록문은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문에 세미콜론 붙이지 않음

```javascript
// 블록문
{
	var foo = 10;
}

// 제어문
var x = 1;
if (x < 10) {
	x++;
}
```

<br>

### 8.2 조건문

+ 주어진 조건식(불리언 값으로 평가될 수 있는 표현식)의 평가 결과에 따라 코드블록의 실행을 결정

#### 8.2.1 if...else문

+ 조건식의 평가 결과에 따라 실행할 코드블록을 결정
+ 조건식이 불리언 값이 아니면 암묵적 타입 변환으로 강제 변환
+ if...else if...else : 조건식을 추가할 때

```javascript
var num = 2;
var kind;

if (num > 0)	kind = '양수';
else if (num < 0) kind = '음수';
else			kind = '영';
console.log(kind); // 양수

var kind = num ? (num > 0 ? '양수' : '음수') : '영';
console.log(kind); // 양수
```

+ 실행해야 할 내용에 따라 삼항 조건 연산자, if...else문을 선택함

#### 8.2.2 switch문

+ 주어진 표현식을 평가해 그 값과 일치하는 표현식을 갖는 case문으로 실행 흐름을 옮김
+ 논리적 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드블록을 결정할 때 사용
+ 다양한 키워드를 사용해야 하고 폴스루(문이 끝날때까지 실행)가 발생하는 등 문법이 복잡 ->  if문으로 해결할 수 있다면 if문 사용

```javascript
var month = 11;
var monthName;

switch (month) {
	case 1: monthName = 'JAN';
		break;
		.
		.
		.
	case 12: monthName = 'FEB';
		break;
	default: monthName = 'Invalid month';
}
```

<br>

### 8.3 반복문

+ 조건식이 참인 경우 코드블록을 실행, 거짓일 때까지 반복

#### 8.3.1 for문

+ 조건식이 거짓일 때까지 실행, 반복 횟수가 명확할 때 사용

```javascript
for (var i=0; i<2; i++) {
	console.log(i); // 0, 1
}

for (var i=1; i<=6; i++) {
    for (var j=1; j<=6; j++) {
        if (i + j === 6) console.log(`[${i}, ${j}]`); // [1,5] [2,4] [3,3] [4,2] [5,1]
    }
}
```

#### 8.3.2 while문

- 조건식이 참이면 실행, 반복 횟수가 불명확할 때 사용

```javascript
var count = 0;

while (count < 3) {
	console.log(count); // 0, 1, 2
	count++; // 선할당 후증가
}
```

#### 8.3.3 do...while문

+ 코드블록을 먼저 실행하고 조건식을 평가, 무조건 한번 이상 실행된다.

```javascript
var count = 0;

do {
	console.log(count); // 0 1 2
	count++;
} while (count < 3);
```

<br>

### 8.4 break문

+ 반복문 또는 switch문의 코드블록을 탈출
+ 그외에서 사용하면 SyntaxError 발생

<br>

### 8.5 continue문

+ 반복문의 코드블록 실행을 현 지점에서 중단하고 증감식으로 실행 흐름을 이동시킨다.
+ if문 내에서 실행해야 할 코드가 많다면 continue문을 사용하는게 가독성이 더 좋다.

```javascript
var string = 'Hello World';
var search = 'l';
var count = 0;

for (var i = 0; i < string.length; i++) {
	if (string[i] !== search) continue; // l이 아니면 증감식으로 이동
	count++; // l이면 실행, 코드가 길다면 continue문이 가독성이 더 좋다.
}

console.log(count); // 3
```

<br>

<br>

# 09장 타입 변환과 단축 평가

### 9.1 타입 변환이란?

+ 명시적 타입 변환 / 타입 캐스팅 : 개발자가 의도적으로 값의 타입을 변환
+ 암묵적 타입 변환 / 타입 강제 변환 : 개발자의 의도와 상관없이 표현식을 평가하는 도중 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환
  - 기존 변수 값을 재할당해 변경하는것이 아닌 새로운 타입의 값을 만들어 단 한 번 사용하고 버림
  - 코드 예측이 중요 -> 암묵적 타입 변환이 어떻게 발생하는지, 어떻게 평가될 것인지 예측

```javascript
var x = 10;

var str = x + '';
console.log(type of str, str); // string 10
console.log(type of x, x); // number 10
```

<br>

### 9.2 암묵적 타입 변환

+ 가급적 에러를 발생시키지 않도록 코드의 문맥을 고려해 암묵적으로 데이터 타입을 변환

```javascript
'10' + 2 // 102 모두 문자열 타입이어야 하는 문맥
5 * '10' // 50 모두 숫자 타입이어야 하는 문맥
```

#### 9.2.1 문자열 타입으로 변환

+ +연산자는 문자열 연결 연산자로 표현식을 평가하기 위해 하나 이상이 문자열인 경우 문자열 타입으로 암묵적 타입 변환 한다.

```javascript
0 + '' // '0'
1 + '' // '1'
NaN + '' // 'NaN'
true + '' // 'true'
null + '' // 'null'
// 모두 string 타입
```

#### 9.2.2 숫자 타입으로 변환

+ -,*,/는 산술 연산자로 피연산자를 숫자 타입으로 암묵적 타입 변환 한다.
+ 비교 연산자의 역할은 불리언 값을 만드는 것으로 모든 피연산자는 코드의 문맥상 숫자 타입이어야 한다.
+ 피연산자를 숫자 타입으로 변환할 수 없는 경우 NaN 반환
+ +단항 연산자는 피연산자가 숫자가 아니면 숫자로 암묵적 타입 변환 한다.

```javascript
+'' // 0
+'0' // 0
+'string' // NaN
+true // 1
+false // 0
+null // 0
// 빈문자열, 빈배열은 0으로 변환된다.
```

#### 9.2.3 불리언 타입으로 변환

```javascript
if(!false)
if(!undefined)
if(!null)
if(!0)
if(!NaN)
if(!'')
// falsy로 평가되는 값 -> 모두 true로 실행된다.
```

<br>

### 9.3 명시적 타입 변환

#### 9.3.1 문자열 타입으로 변환

```javascript
// 1. string 생성자 함수를 new 연산자 없이 호출
String(1); // '1'
String(true); // 'true'

// 2. Object.prototype.toString 메서드를 사용
(1).toString(); // '1'
(NaN).toString(); // 'NaN'
(true).toString(); // 'true'

// 3. 문자열 연결 연산자를 이용하는 방법
1 + ''; // '1'
true + ''; // 'true'
```

#### 9.3.2 숫자 타입으로 변환

```javascript
// 1. Number 생성자 함수를 new 연산자 없이 호출
Number('0'); // 0
Number('true'); // 1

// 2. parseInt, parseFloat 함수를 사용
parseInt('0'); // 0
parseFloat('10.53'); // 10.53

// 3. +단항 산술 연산자를 이용
+'0'; // 0
+true; // 1

// 4. *산술 연산자를 이용
'0' * 1; // 0
true * 1; // 1
```

#### 9.3.3 불리언 타입으로 변환

```javascript
// 1. Boolean 생성자 함수를 new 연산자 없이 호출
Boolean('x'); // true
Boolean(''); // false
Boolean({}); // true

// 2. !부정 논리 연산자를 두 번 사용하는 방법
!!'x'; // true
!!''; // false
!!null; // false
```

<br>

### 9.4 단축 평가

#### 9.4.1 논리 연산자를 사용한 단축 평가

+ 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다.

+ 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것

+ true || anything = true

  false || anything = anything

  true && anything = anything

  false && anything = false

```javascript
// 논리합 연산자
'cat' || 'dog' // 'cat'
false || 'dog' // 'dog'
'cat' || false // 'cat'

// 논리곱 연산자
'cat' && 'dog' // 'dog'
false && 'dog' // false
'cat' && false // false
```

+ 어떤 조건이 Truthy 값일 때 무언가를 해야한다면 논리곱 연산자 표현식으로 if문을 대체할 수 있다.

```javascript
var done = true;
var message = '';

message = done && '완료';
console.log(message); // '완료'
```

+ 어떤 조건이 Falsy 값일 때 무언가를 해야한다면 논리합 연산자 표현식으로 if문을 대체할 수 있다.

```javascript
var done = false;
var message = '';

message = done || '미완료';
console.log(message); // '미완료'
```

+ 단축 평가는 다음과 같은 상황에서 유용하게 사용된다.

  - 객체를 상대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때

  ```javascript
  var element = null;
  
  var value = element.value; // TypeError
  // null로 선언된 객체의 프로퍼티를 참조하려고 해서 에러가 발생
  
  var value = element && element.value // null
  // 1) element가 null이면 false로 평가되므로 그대로 element(null) 할당
  // 2) element가 null이 아니면 truthy로 평가되므로 프로퍼티를 할당
  ```

  - 함수 매개변수에 기본값을 설정할 때

  ```javascript
  function getName(name) {
  	var userName = name;
  	return = userName;
  }
  
  getName(); // undefined
  // name 매개변수에 값이 없으므로 자동적으로 undefined가 할당된다. 다른곳에서 참조할 경우 에러발생 가능성!!
  
  function getName(name) {
  	var userName = name || '무명';
  	return = userName;
  }
  
  getName('김서영'); // '김서영'
  getName(); // '무명'
  // 1) name 매개변수에 값이 있다면 truthy로 평가되므로 그대로 값을 사용
  // 2) name 매개변수에 값이 없다면(undefined) falsy로 평가되므로 '무명' 사용
  ```

#### 9.4.2 옵셔널 체이닝 연산자 (?.)

+ ES11에서 도입된 것으로 도입되기 이전에는 논리연산자 &&를 사용한 단축평가를 통해 변수를 확인했다.

+ 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고 그렇지 않으면 우항의 프로퍼티를 참조한다. ->  좌항이 null 이 아니면(true) 우항
+ 객체의 프로퍼티를 참조할 때 null 체크를 편하게 할 수 있다.

```javascript
var element = null;

var value = element?.value;
console.log(value); // undefined
// 좌항의 피연산자가 null 이므로 undefined 반환

var str = '';

var length = str?.length;
console.log(length); // 0
// 좌항의 피연산자가 falsy 값이라도 null 또는 undefined 가 아니므로 우항의 프로퍼티를 참조해 0이 된다.
```

#### 9.4.3 null 병합 연산자 (??)

+ ES11에서 도입된 것으로 도입 이전에는 논리연산자 ||를 사용한 단축평가를 통해 변수를 확인했다.
+ 좌항의 피연산자가 null 또는 undefined인 경우 우항을 반환하고 그렇지 않으면 좌항을 반환한다. -> 좌항이 null 이 아니면(true) 좌항
+ 변수를 참조할 때 null 체크를 편하게 할 수 있다.

```javascript
var foo = null ?? 'default string';
console.log(foo); // 'default string'
// 좌항 null 이므로 우항 반환

var foo = '' ?? 'default string';
console.log(foo); // ''
// 좌항이 falsy 값이라도 null 또는 undefined 가 아니므로 좌항 반환
```

<br>

<br>

# 10장 객체 리터럴

### 10.1 객체란

+ 상태와 동작을 하나의 단위로 구조화할 수 있어서 유용

+ 원시값을 제외한 자바스크립트를 구성하는 함수, 배열, 정규 표현식 등은 모두 객체

+ 원시타입의 값은 변경불가능하지만 객체는 변경가능한 값이다.

+ 객체는 객체의 상태를 나타내는 값(프로퍼티)과 프로퍼티를 참조하고 조작할 수 있는 동작(메서드)을 모두 포함한다.

  - 프로퍼티 : 객체의 상태를 나타내는 값(data)
  - 메서트 : 프로퍼티를 참조하고 조작할 수 있는 동작(behavior)

  ```javascript
  var counter = {
  	num: 0; // 프로퍼티
  	increase: function() {
  		this.num++; // 메서드
  	}
  };
  ```

<br>

### 10.2 객체 리터럴에 의한 객체 생성

+ 다양한 객체 생성 방법을 지원 

+ 객체 리터럴 / Object 생성자 함수 / 생성자 함수 / Object.create 메서드 / 클래스(ES6)

  - 객체 리터럴 : 중괄호 내에 0개 이상의 프로퍼티를 정의하며 변수에 할당되는 시점에 객체 리터럴을 해석해 객체를 생성

  ```javascript
  var person = {
  	name: 'Kim',
  	sayHello: function() {
  		console.log(`Hello! My name is &{this.name}.`0);
  	}
  };
  //객체 리터럴은 값으로 평가되는 표현식이며 코드블록이 아니기에 닫는 중괄호 뒤에 세미콜론을 붙인다.
  
  console.log(typeof person); // object
  ```


<br>

### 10.3 프로퍼티

+ 객체는 프로퍼티의 집합이며 키와 값으로 구성된다.

+ 프로퍼티를 나열할 때는 쉼표로 구분한다.

+ 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 심벌 값 / 가급적 네이밍 규칙을 준수하는 프로퍼티 키를 사용 / 암묵적 타입 변환으로 문자열이 됨

  중복 선언하면 먼저 선언한 프로퍼티를 덮어쓰고 에러를 발생하지 않으니 주의

+ 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값

<br>

### 10.4 메서드

+ 객체에 묶여있는 함수 = 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 부른다.

<br>

### 10.5 프로퍼티 접근

+ 마침표 표기법 : 반드시 식별자 네이밍 규칙을 준수해야 한다. (SyntaxError 발생)

```javascript
var person = {
	name: "Kim"
    'last-name': "Kim",
    1: 10
};

console.log(person.name); // Kim
person.'last-name'; // SyntaxError
person.'1'; // SyntaxError
```

+ 대괄호 표기법 : 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다. (ReferenceError 발생)

```javascript
var person = {
	name: "Kim"
};

console.log(person[name]); // ReferenceError
```

+ 존재하지 않는 프로퍼티에 접근하면 undefined 를 반환

<br>

### 10.7 프로퍼티 동적 생성 / 삭제

```javascript
var person = {
	 name: 'Kim'
};

person.age = 20; // 존재하지 않는 프로퍼티를 동적으로 생성할 수 있다.

console.log(person); // {name: "Kim", age: 20}

delete person.age; // age 프로퍼티를 삭제할 수 있다.
```

<br>

### 10.9 ES6에서 추가된 객체 리터럴의 확장 기능

#### 10.9.1 프로퍼티 축약 표현

+ 프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일하면 키를 생략할 수 있다. 변수 이름으로 자동 생성된다.

```javascript
let x = 1, y = 2;

const obj = {x, y};

console.log(obj); // {x: 1, y: 2}
```

#### 10.9.2 계산된 프로퍼티 이름

+ 문자열 또는 문자열로 타입 변환할 수 있는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수 있다. 대괄호를 사용한다.
+ 프로퍼티 키와 값의 제약을 없애주기 때문에 더 강력하지만 작성이 번거로워 마침표 표기법 사용 중 복잡한 상황이 생길 때 사용한다.

```javascript
var prefix = 'prop';
var i = 0;

var obj = {};

obj[prefix + '-' + ++i] = i; // 계산된 프로퍼티 이름으로 프로퍼티 키를 동적으로 생성
obj[prefix + '-' + ++i] = i;

console.log(obj); // {prop-1: 1, prop-2: 2}
```

```javascript
var fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");

var bag = {
	[fruit]: 5, // 변수에서 프로퍼티 키를 동적으로 받아옴
};

alert(bag.apple); // 5
```

#### 10.9.3 메서드 축약 표현

+ ES5에서 메서드를 정의하려면 프로퍼티 값으로 함수를 할당한다.
+ ES5 선언 방식은 현재 사양에서는 일반 함수로 정의된다. -> new 로 인스턴스를 생성할 수 있다.

```javascript
var obj = {
	name: "kim",
	sayHi: function() {
		console.log('Hi! ' + this.name);
	}
};

obj.sayHi(); // Hi! kim
```

+ ES6에서는 메서드를 정의할 때 축약 표현을 사용할 수 있다.
+ ES6 메서드 축약 표현만 메서드로 인정한다. -> 일반 함수가 아니므로 new 로 인스턴스를 생성할 수 없다. (TypeError)

```javascript
const obj = {
	name: "Kim",
	sayHi() {
		console.log('Hi! ' + this.name);
	}
};

obj.sayHi(); // Hi! Kim
```

<br>

<br>

# 11장 원시 값과 객체의 비교

+ 원시 값은 변경 불가능한 값 / 객체는 변경 가능한 값

+ 원시 값을 변수에 할당하면 실제 값의 메모리 주소가 저장 / 객체를 변수에 할당하면 참조 값의 메모리 주소가 저장 -> 실제 객체의 메모리 주소를 저장

+ 원시 값을 갖는 변수에 다른 변수를 할당하면 원본의 원시 값이 복사되어 전달 -> 값에 의한 전달

  객체를 참조하는 변수에 다른 변수를 할당하면 참조 값이 복사되어 전달 -> 참조에 의한 전달

### 11.1 원시 값 (primitive type)

#### 11.1.1 변경 불가능한 값

+ 변수(재할당을 통해 값을 교체) / 상수(재할당이 금지된 변수)와 구분해서 이해할 것
+ 불변성 : 원시 값을 재할당하면 이전의 원시 값을 변경하는 것이 아닌 새로운 메모리 공간을 확보하고 재할당한 값을 저장한다. 그 후 변수가 참조하던 메모리 공간의 주소를 변경한다.
+ 신뢰성 : 한 번 생성된 원시 값은 읽기 전용 값으로서 변경할 수 없다.
+ 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다. -> 변경이 자유롭다면 상태 변경을 추적하기 어렵게 만든다.

#### 11.1.2 문자열과 불변성

+ 자바스크립트는 개발자의 편의를 위해 원시 타입인 문자열 타입을 제공한다. C에서는 배열, 자바에서는 String 객체로 처리

+ 문자열 타입 : 저장하려는 값의 크기에 따라 필요한 메모리 공간의 크기가 결정된다. (1개의 문자 = 2바이트, 10개의 문자 = 20바이트)
+ 숫자 타입 : 8바이트의 고정된 크기로 규정되어 있다. (1개의 숫자 = 8바이트, 10개의 숫자 = 8바이트)

+ 유사 배열 객체 : 문자열은 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티 값을 가진다.

+ 이미 생성된 문자열의 일부 문자를 변경해도 변경되지 않지만 에러는 발생하지 않는다.

```javascript
var str = "string";
str[0] = "S"; // 유사배열객체 : 인덱스로 프로퍼티 값이 접근할 수 있고, length 프로퍼티 값을 가진다.
console.log(str); // string
```

#### 11.1.3 값에 의한 전달

+ 변수에 변수를 할당했을 때 할당받는 변수에는 할당되는 변수의 원시 값이 복사되어 전달된다. 이는 다른 메모리 공간에 저장된 별개의 값이다.

+ 엄격하게 표현하면 값이 전달되는 것이 아니라 값이 저장된 메모리 주소를 전달하는 것이다.

  1. 변수에 원시 값을 할당하는 시점에는 같은 메모리 주소를 기억하고 있다가 어느 한쪽에 재할당이 이루어지면 새로운 메모리 주소를 저장하는 경우

  2. 변수에 원시 값을 할당하는 시점부터 새로운 메모리 주소를 전달해서 서로 다른 메모리 주소를 기억하는 경우

```javascript
var score = 80;
var copy = score;

console.log(score === copy); // true

score = 100;

console.log(score === copy); // false
// score 변수와 copy 변수에 저장된 값은 다른 메모리 공간에 저장된 별개의 값이므로 서로 영향을 주지 않는다.
```

<br>

### 11.2 객체 (object)

+ 객체는 복합적인 자료구조이므로 관리하는 방식이 원시 값과 비교해서 복잡하고 구현 방식도 브라우저 제조사마다 다를 수 있다.
+ 객체는 경우에 따라 크기가 매우 클 수도 있다. -> 프로퍼티의 개수나 값에 제한이 없다.

#### 11.2.1 변경 가능한 값

+ 객체를 할당한 변수는 "객체를 참조하고 있다" 라고 표현한다.

+ 객체를 할당한 변수는 재할당 없이 객체를 직접 수정할 수 있다. 
+ 객체를 변경 가능한 값으로 설계한 이유
  - 객체는 크기가 매우 클수도, 크기가 일정하지도, 프로퍼티 값이 객체일 수도 있어서 복사할 때 비용이 많이 든다.
  - 메모리를 효율적으로 사용하고 성능을 향상시키기 위한 구조적인 단점을 감안한 설계이다.
  - 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 단점이 있다.

#### 11.2.2 참조에 의한 전달

+ 객체를 참조하는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다.
+ 변수가 저장된 메모리 주소는 다르지만 동일한 참조 값을 가지며 동일한 객체를 가리킨다. -> 두개의 식별자가 하나의 객체를 공유
+ 원본 또는 사본 중 참조된 객체의 프로퍼티를 수정하면 서로 영향을 주고 받게 된다.

```javascript
var person = {
	name: "Kim"
};

var copy = person;

copy.name = "Lee";
person.address = "Suwon";

console.log(name); // {name: "Lee", address: "Suwon"}
console.log(person); // {name: "Lee", address: "Suwon"}
// 같은 참조 값을 갖기 때문에 어느 한쪽에서 객체를 변경하면 서로 영향을 받는다.
```

+ 자바스크립트의 동작 방식을 설명하는 정확한 용어가 존재하지 않기에 전달되는 값의 종류가 원시 값인지, 참조 값인지 구별해서 강조하는 의미에서 각각 "값에 의한 전달", "참조에 의한 전달"로 구분해 부르기로 한다.

```javascript
var person1 = {
	name: "Kim"
};

var person2 = {
	name: "Kim"
};

console.log(person1 === person2); // false
// 객체 리터럴은 평가 될때마다 객체를 생성한다. 각 변수는 다른 메모리에 저장된 별개의 객체다. 참조값은 전혀 다른 값이다.

console.log(person1.name === person2.name); // true
// 참조되는 프로퍼티 값은 표현식이므로 원시 값을 비교한다.
```

<br>

<br>

# 12장 함수

### 12.1 함수란?

+ 변수(매개변수)를 통해 인수를 입력 받아 반환값을 출력하는 과정
+ 일련의 과정을 문으로 구현하고 코드블록으로 감싸 하나의 실행 단위로 정의한 것
+ 함수는 값이며 여러 개 존재할 수 있으므로 특정 함수를 구별하기 위해 식별자를 사용한다.
+ 함수 정의 -> 함수 호출을 통해 실행

```javascript
function add(x, y) {
	return x + y;
}
// 함수 정의

add(3, 8); // 11
// 함수 호출
```

<br>

### 12.2 함수를 사용하는 이유

+ 같은 작업을 반복 실행할 때 코드를 여러번 작성하면 중복된 횟수만큼 코드 작성이 길어지고 코드 수정에도 오래 걸린다.
+ 함수는 필요할 때 재사용이 가능해서 미리 정의된 함수를 사용하면 코드의 중복을 억제해 유지보수의 편의성이 높아지고 신뢰성도 높아진다.
+ 함수는 객체 타입의 값이기 때문에 식별자를 붙일 수 있고, 코드의 가독성을 향상시키기 위해 역할을 잘 나타내는 이름(식별자)를 사용해야 한다.

<br>

### 12.3 함수 리터럴

+ 함수 이름 : 식별자 네이밍 규칙을 준수, 함수 몸체 내에서만 참조 가능, 기명함수와 익명함수가 있다.
+ 매개변수 목록 : 함수 몸체 내에서 변수와 동일하게 취급되므로 식별자 네이밍 규칙을 준수
+ 함수 몸체 : 함수 호출시 실행되어야 하는 문들을 정의한 코드 블록
+ 함수는 일반 객체와는 다른 함수 객체로 고유한 프로퍼티를 갖는다. (자바스크립트의 중요한 특징)
+ 일반 객체는 호출할 수 없지만 함수 객체는 호출할 수 있다.

```javascript
var f = function add(x, y) {
	return x + y;
};
// 함수 리터럴은 값으로 평가되는 표현식으로 코드블록과 다르기에 자체종결성이 없어 세미콜론을 붙여야 한다.
```

<br>

### 12.4 함수 정의

+ 정의 : 변수에 값을 할당해 변수의 실체를 명확히 하는 것
+ 함수 정의 방법 : 함수 선언문, 함수 표현식, Function 생성자 함수, 화살표 함수(ES6)

#### 12.4.1 함수 선언문

+ 함수 리터럴과 형태가 동일하지만, 함수 선언문은 함수 이름을 생략할 수 없다. -> 함수 표현식과 비교

```javascript
function add(x, y) {
	return x + y;
}
// 함수 선언문은 자체종결성을 가지는 코드블록으로 세미콜론을 생략할 수 있다.
```

+ 함수 선언문은 표현식이 아닌 문이다. -> 변수에 할당할 수 없지만 할당되는 것처럼 보인다.

```javascript
var add = function add(x, y) {
	return x + y;
};
// 함수 선언문은 변수에 할당할 수 없지만 할당되는 것처럼 보인다. 그런데 이것은 함수 표현식이 아닌가..?

console.log(add(2, 5)); // 7
```

+ 자바스크립트 엔진은 코드의 문맥에 따라 기명함수 리터럴을 다르게 해석하고 함수를 생성하는 내부 동작도 다르게 한다.

  - 함수 선언문 : {}이 단독으로 존재, 함수 리터럴을 피연산자로 사용하지 않는 경우
  - 함수 리터럴 표현식 : 값으로 평가되어야 할 문맥 (할당 연산자), 피연산자로 사용하는 경우

  ```javascript
  function foo() { console.log('foo'); }
  foo(); // 함수 선언문으로 해석된다.
  // 자바스크립트 엔진이 암묵적으로 생성한 식별자로 호출한다.
  
  (function bar() { console.log('bar'); });
  bar(); // 그룹연산자()의 피연산자로 사용했기 때문에 함수 리터럴로 해석된다.
  // 함수를 가리키는 식별자가 없기 때문에 호출할 수 없다. (ReferenceError) -> 변수에 할당해서 함수 표현식으로 써봐용
  ```

  - 함수 이름 bar는 함수 몸체 내에서만 참조할 수 있는 식별자이므로 함수를 호출할 수 없다.
  - 함수 이름 foo는 자바스크립트 엔진이 암묵적으로 생성한 함수 객체를 가리키는 식별자이다. 

+ 자바스크립트 엔진은 함수 선언문을 해석하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 거기에 함수 객체를 할당한다. 이는 함수 표현식으로 변환한다고도 할 수 있다.

#### 12.4.2 함수 표현식

+ 일급 객체 
  - 값처럼 변수에 할당할 수 있다. 
  - 프로퍼티 값이나 배열의 요소가 될 수 있다.
  - 함수를 값처럼 자유롭게 사용할 수 있다.
+ 함수 표현식 : 함수 리터럴로 생성한 함수 객체를 변수에 할당하는 정의 방식
+ 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적 -> 함수 이름이 아닌 함수 객체를 가리키는 식별자를 사용해야 한다.

```javascript
var add = function foo (x, y) {
	return x + y;
};

console.log(add(2, 5)); // 7
console.log(foo(2, 6)); // ReferenceError 몸체 내부에서만 유효한 식별자
```

#### 12.4.3 함수 생성 시점과 함수 호이스팅

+ 호이스팅 : 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징 (런타임 이전에 먼저 실행)

```javascript
// 함수 참조
console.dir(add); // f add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 6)); // 7
console.log(sub(2, 6)); // TypeError

function add(x, y) {
	return x + y;
}
// 함수 선언문으로 정의한 함수는 호이스팅에 의해 선언 이전에 참조와 호출이 가능하다. 동일한 이름의 식별자를 암묵적으로 생성하고 객체를 할당한다.

var sub = function (x, y) {
	return x + y;
};
/* 함수 표현식으로 정의한 함수는 var 키워드를 사용해 변수를 선언했기 때문에 undefined로 초기화되고 변수 호이스팅이 일어난다.
호출할때는 undefined가 호출되는 것과 마찬가지이므로 TypeError가 발생한다. */
```

#### 12.4.4 Function 생성자 함수

+ Function 생성자 함수로 생성하는 방식은 일반적이지 않다.
+ 클로저를 생성하지 않는다.

```javascript
var add = new Function('x', 'y', 'return x + y');
console.log(add(1, 2)); // 3
```

#### 12.4.5 화살표 함수

+ ES6에서 도입
+ 항상 익명 함수로 정의
+ 생성자 함수로 사용할 수 없고 기존 함수와 this 바인딩 방식이 다르며 prototype 프로퍼티가 없고 arguments 객체를 생성하지 않는다.

```javascript
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```

<br>

### 12.5 함수 호출

#### 12.5.1 매개변수와 인수

+ 함수를 실행하기 위해 매개변수를 통해 인수를 전달받는다. 인수는 표현식이어야 한다.
+ 매개변수는 함수 몸체 내부에서만 참조할 수 있다.

```javascript
function add(x, y) {
	console.log(x, y); // 2 5
	return x + y;
}

add(2, 5);

console.log(x, y)// ReferenceError
```

+ 매개변수의 개수와 인수의 개수는 일치하지 않아도 된다.
  - 부족할 경우 : undefined로 할당
  - 초과될 경우 : 무시되지만 암묵적으로 arguments 객체의 프로퍼티로 보관

#### 12.5.2 인수 확인

+ 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다. -> 단축평가 / 매개변수 기본값 사용
+ 자바스크립트는 동적 타입 언어로 매개변수의 타입을 사전에 지정할 수 없다. -> 정적 타입 선언이 가능한 타입스크립트 사용

```javascript
function add(x, y) {
	return x + y;
}

console.log(add(1)); // NaN
console.log(add('a', 'b')); // 'ab'



// 함수 내부에 적절한 인수가 전달되었는지 확인하는 if문 작성
function add(x, y) {
    if (typeof x != 'number' || typeof y != 'number') {
        throw new TypeError('인수는 모두 숫자로 통일하라');
    }
	return x + y;
}

console.log(add(1)); // TypeError('인수는 모두 숫자로 통일하라')
console.log(add('a', 'b')); // TypeError('인수는 모두 숫자로 통일하라')
```

+ 단축평가 / 매개변수 사용

```javascript
// 논리합 연산자를 이용한 단축 평가
function add(a, b, c) {
	a = a || 0;
	b = b || 0;
	c = c || 0;
	return a + b + c;
}

// 매개변수 기본값 (인수를 전달하지 않을 경우, undefined를 전달한 경우)
function add(a=0, b=0, c=0) {
	return a + b + c;
}

console.log(add(1,2,3)); // 6
console.log(add(1,2)); // 3
console.log(add(1)); // 1
console.log(add()); // 0

```

#### 12.5.3 매개변수의 최대 개수

+ 명시적으로 제한하고 있지 않다.
+ 매개변수가 늘어날수록 유지보수성이 나빠진다.
+ 이상적인 매개변수는 0개이며 최대 3개
+ 객체를 인수로 전달 : 프로퍼티 키만 정확히 지정하면 순서에 상관없이 전달할 수 있다. 하지만 함수 내부를 변경하면 함수 외부의 객체가 변경되는 부수효과가 발생할 수 있다.

#### 12.5.4 반환문

+ return 키워드와 표현식(반환값)으로 이뤄진 반환문을 사용해 실행 결과를 함수 외부로 반환할 수 있다.
+ 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다.

```javascript
function multiply(x, y) {
	return x * y;
	console.log('이것은 실행되지 않아용');
}
```

+ 반환문은 return 키워드 뒤에 오는 표현식을 평가해 반환한다. 지정하지 않거나 생략하면 undefined를 반환한다.

```javascript
function multiply(x, y) {
	return; // undefined
}

function multiply(x, y) {
	// undefined
}
```

+ return 키워드와 표현식 사이에 줄바꿈이 있으면 자동으로 세미콜론이 추가되어 의도치 않은 결과가 발생한다.
+ 함수 몸체 내부에서만 사용할 수 있고 전역에서 사용하면 SyntaxError가 발생한다.

<br>

### 12.6 참조에 의한 전달과 외부 상태의 변경

+ 원시 타입 인수 : 함수 외부에서 함수 몸체 내부로 전달한 원시 값의 원본을 변경하는 어떠한 부수효과도 발생하지 않는다.
+ 객체 타입 인수 : 함수 외부에서 함수 몸체 내부로 전달한 참조 값에 의해 원본 객체가 변경되는 부수효과가 발생한다.
+ 객체가 변경할 수 있는 값이며 참조에 의한 전달 방식으로 동작하기 때문에 상태 변화를 추적하기 어렵다.
+ 객체의 방어적 복사를 통해 원본 객체를 완전히 복제(깊은 복사)를 통해 새로운 객체를 생성하고 재할당을 통해 교체한다.
+ 순수 함수 : 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수
+ 함수형 프로그래밍 : 순수 함수를 통해 부수효과를 최대한 억제해 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 기법

<br>

### 12.7 다양한 함수의 형태

#### 12.7.1 즉시 실행 함수

+ 함수 정의와 동시에 즉시 호출되는 함수
+ 단 한 번 호출되며 다시 호출할 수 없다.
+ 그룹 연산자로 함수를 묶어 사용한다.
+ 즉시 실행 함수 내에 코드를 모아두면 혹시 있을 수도 있는 변수나 함수 이름의 충돌을 방지할 수 있다.

```javascript
(function () {
	var a = 3;
	var b = 5;
	return a * b;
}());
// 익명 즉시 실행 함수 : 피연산자로 사용하는 경우 -> 함수 리터럴 표현식

(function foo() {
    var a = 3;
    var b = 5;
    return a * b;
}());
// 기명 즉시 실행 함수 : 함수 이름은 함수 몸체에서만 참조할 수 있다.

var res = (function () {
    var a = 3;
    var b = 5;
    return a * b;
}());
console.log(res); // 15
// 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있다.

res = (function (a, b) {
    return a * b;
}(3, 5));
console.log(res); // 15
// 즉시 실행 함수에도 일반 함수처럼 인수를 전달할 수 있다.
```

#### 12.7.2 재귀 함수

+ 함수가 자기 자신을 호출하는 것
+ 반복되는 처리를 위해 사용
+ 팩토리얼은 재귀 함수로 간단히 구현할 수 있다.
+ 탈출 조건을 반드시 만들어야 한다 -> 스택 오버플로우 발생
+ 반복문 없이 반복되는 처리를 구현할 수 있다는 장점이 있지만 직관적으로 이해하기 쉬울때만 사용

```javascript
function countdown(n) {
	for (var i = n; i >= 0; i--) console.log(i);
}
countdown(10);
// 10부터 0까지 출력하는 함수

function countdown(n) {
    if(n < 0) return; // 탈출 조건 : n이 0보다 작을때 재귀 호출을 멈춘다.
    console.log(n);
    countdown(n - 1); // 재귀 호출
}
countdown(10);

function factorial(n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}
console.log(factorial(0)); // 0! = 1
console.log(factorila(5)); // 5! = 5 * 4 * 3 * 2 * 1 = 120
// 함수 선언문
```

#### 12.7.3 중첩 함수

+ 함수 내부에 정의된 함수
+ 외부 함수의 변수를 참조할 수 있다.
+ 호이스팅으로 인해 혼란이 발생할 수 있으므로 if문이나 for문 등의 코드 블록에서 정의하는 것은 바람직하지 않다.

#### 12.7.4 콜백 함수

+ 반복문 내부에서 다른 일을 하고 싶다면 함수를 새롭게 정의해야 한다.

```javascript
function repeat1(n) {
	for (var i = 0; i < n; i++) console.log(i); // i를 출력한다.
}
repeat1(5); // 0 1 2 3 4

function repeat2(n) {
	for (var i = 0; i < n; i++) {
		if (i % 2) console.log(i); // i가 홀수일때만 출력한다.
	}
}
repeat2(5); // 1 3
```

+ 함수의 변하지 않는 공통 로직은 미리 정의해 두고, 경우에 따라 변경되는 로직은 추상화해서 함수 외부에서 함수 내부로 전달한다.
+ 콜백 함수 : 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수, 고차 함수에 의해 호출, 비동기 처리에 활용,  배열 고차 함수에서 사용
+ 고차 함수 : 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수, 콜백 함수를 자신의 일부분으로 합성

```javascript
// 경우에 따라 변경되는 일을 콜백 함수 f로 매개변수를 통해 추상화
function repeat(n, f) {
    for (var i = 0; i < n; i++) {
        f(i);
    }
}

var logAll = function (i) {
    console.log(i);
};

var logOdds = function (i) {
    if (i % 2) console.log(i);
};

repeat(5, logAll); // 0 1 2 3 4
repeat(5, logOdds); // 1 3
```

+ 콜백 함수가 고차함수 내부에만 호출된다면 콜백 함수를 익명함수 리터럴로 정의할 수 있다.

```javascript
repeat(5, function (i) {
    if (i % 2) console.log(i);
}); // 1 3
```

#### 12.7.5 순수 함수와 비순수 함수

+ 순수 함수

  - 부수 효과가 없는 함수
  - 매개변수를 통해 함수 내부로 전달된 인수에게만 의존해 값을 생성해 반환
  - 외부 상태에 의존하지 않으며 외부 상태를 변경하지도 않는 함수

  ```javascript
  var count = 0;
  
  function increase(n) {
  	return ++n; // 동일한 인수가 전달되면 언제나 동일한 값을 반환
  }
  
  count = increase(count);
  console.log(count); // 1
  
  count = increase(count);
  console.log(count); // 2
  ```

+ 비순수 함수

  - 부수 효과가 있는 함수
  - 외부 상태에 의존하거나 외부 상태를 변경하는 함수
  - 인수를 전달받지 않고 함수 내부에서 외부 상태를 직접 참조
  - 함수 내부에서 외부 상태를 직접 참조하지 않더라도 매개변수를 통해 객체를 전달받을 때

  ```javascript
  var count = 0;
  
  function increase() {
  	return ++count;
  }
  
  increase();
  console.log(count); // 1
  
  increase();
  console.log(count); // 2
  ```

+ 함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워진다.

+ 비순수 함수는 코드의 복잡성을 증가시킨다.

+ 함수형 프로그래밍

  - 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임
  - 로직 내에 존재하는 조건문과 반복문을 제거해서 복잡성을 해결 -> 로직의 흐름을 이해하기 어렵게 해서 가독성을 해침
  - 변수 사용을 억제하거나 생명주기를 최소화해서 상태 변경을 피해 오류를 최소화 -> 변수는 언제든지 변경될 수 있음

<br>

<br>

# 13장 스코프

### 13.1 스코프란?

+ 모든 식별자(변수이름, 함수이름, 클래스이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다.
+ 식별자가 유효한 범위
+ 렉시컬 환경(Lexical Environment) : 코드가 어디서 실행되며 주변에 어떤 코드가 있는지
+ 스코프 내에서 식별자는 유일해야 하지만 다른 스코프에는 같은 이름의 식별자를 사용할 수 있다. -> 네임스페이스

```javascript
var x = 'global';

function foo() {
	var x = 'local';
	console.log(x); // 'local'
}

foo();

console.log(x); // 'global'
// 두 개의 변수는 식별자 이름이 동일하지만 자신이 유효한 범위, 즉 스코프가 다른 별개의 변수다.
```

+ var 키워드 : 같은 스코프 내에서 중복 선언이 허용 -> 변수값이 재할당되어 변경되는 부작용을 발생시킴
+ let, const 키워드 : 같은 스코프 내에서 중복 선언을 허용하지 않음

<br>

### 13.2 스코프의 종류

+ 전역 : 코드의 가장 바깥 영역
+ 지역 : 함수 몸체 내부

#### 13.2.1 전역과 전역 스코프

+ 전역에 선언된 변수는 어디서든 참조할 수 있다.

#### 13.2.2 지역과 지역 스코프

+ 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.
+ 함수 내부에서 선언된 변수 이외에 이름이 같은 전역 변수가 존재하면 스코프 체인을 통해 참조할 변수를 검색해 내부에서 선언된 변수를 참조한다.

<br>

### 13.3 스코프 체인

+ 자바스크립트 엔진은 변수를 참조할 때 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작해 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.
+ 모든 스코프는 하나의 계층적 구조로 연결되며 모든 지역 스코프의 최상위 스코프는 전역 스코프다.

#### 13.3.1 스코프 체인에 의한 변수 검색

+ 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수는 없다.
+ 하위->상위로 검색

#### 13.3.2 스코프 체인에 의한 함수 검색

+ 함수도 식별자에 할당되기 때문에 스코프를 갖는다.

```javascript
function foo() {
	console.log('global');
}

function bar() {
	function foo() {
		console.log('local');
	}
	foo(); // 'local'
}

bar();
```

<br>

### 13.4 함수 레벨 스코프

+ 함수 레벨 스코프 : var 키워드로 선언된 변수는 오로지 함수의 코드블록만을 지역 스코프로 인정한다. 나머지는 모두 전역변수
+ 블록 레벨 스코프 : C나 자바 등을 비롯한 대부분의 프로그래밍 언어는 모든 코드 블록이 지역 스코프를 만든다.
+ let, const 키워드는 블록 레벨 스코프를 지원한다.

<br>

### 13.5 렉시컬 스코프

+ 동적 스코프 : 함수를 정의하는 시점에는 함수가 어디서 호출될지 알 수 없다. 함수가 호출되는 시점에 동적으로 상위 스코프를 결정한다.
+ 렉시컬 스코프 / 정적 스코프 : 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정된다. 
+ 함수가 어디서 정의되었는가! 호출 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다.

```javascript
var x = 1;

function foo() {
	var x = 10;
	bar(); // 함수를 어디서 호출했는지는 영향이 없다.
}

function bar() {
	console.log(x);
}
// 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다. -> 전역 스코프

foo(); // 1
bar(); // 1
// 함수를 어디서 호출했는지는 영향이 없다.
```

<br>

<br>

# 14장 전역 변수의 문제점

### 14.1 변수의 생명 주기

#### 14.1.1 지역 변수의 생명 주기

+ 전역 변수의 생명 주기는 애플리케이션의 생명 주기와 같다
+ 지역 변수의 생명 주기는 함수의 생명 주기와 같다.
+ 함수 내부에서 선언한 변수는 함수가 호출된 직후에 함수 몸체의 코드가 순차적으로 실행되기 이전에 호이스팅 된다.
+ 호이스팅 : 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

```javascript
var x = 'global';

functuon foo() {
	console.log(x);
	var x = 'local'; // x가 호출될때 이미 호이스팅 되었다.
}

foo(); // 'local'
console.log(x); // 'global'
```

#### 14.1.2 전역 변수의 생명 주기

+ 전역 객체

  - 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 객체

  - 클라이언트(브라우저) : window / 서버(Node.js) : global

+ var 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티며 생명 주기는 전역 객체의 생명주기와 일치한다.

<br>

### 14.2 전역 변수의 문제점

+ 암묵적 결합 : 전역 변수를 선언한 의도는 코드 어디서든 참조하고 할당할 수 있는 변수를 사용하겠다는 것으로 모든 코드가 전역 변수를 참조하고 변경할 수 있다. -> 의도치 않게 변수의 상태가 변경될 수 있다.
+ 긴 생명 주기 : 전역 변수는 생명주기가 길어 메모리 리소스를 오랜 시간 소비한다. 또한 var 키워드는 변수의 중복 선언을 허용해 변수 이름이 중복될 가능성이 생긴다. -> 의도치 않은 재할당 발생
+ 스코프 체인 상에서 종점에 존재 : 변수를 검색할 때 전역 변수가 가장 마지막에 검색되므로 검색 속도가 가장 느리다.
+ 네임스페이스 오염 : 파일이 분리되어 있어도 하나의 전역 스코프를 공유하기 때문에 다른 파일에서 동일한 이름으로 명명된 전역 변수나 전역 함수에 의해 예상치 못한 결과를 가져올 수 있다.

<br>

### 14.3 전역 변수의 사용을 억제하는 방법

#### 14.3.1 즉시 실행 함수

+ 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.
+ 전역 변수를 생성하지 않으므로 라이브러리 등에 자주 사용된다.

```javascript
(function () {
	var foo = 10; // 즉시 실행 함수의 지역 변수
}());

console.log(foo); // ReferenceError
```

#### 14.3.2 네임스페이스 객체

+ 네임스페이스를 분리해 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가한다.
+ 식별자 충돌을 방지하는 효과는 있으나 네임스페이스 객체 자체가 전역 변수에 할당되므로 유용하지 않다.

```javascript
var MYAPP = {}; // 전역 네임스페이스 객체

MYAPP.name = 'Kim';
```

#### 14.3.3 모듈 패턴

+ 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다.
+ 클로저 기능을 통해 전역 변수를 억제할 수 있다.
+ 대부분의 객체지향 프로그래밍 언어는 클래스 멤버에 대해 public, private, protected 등의 접근 제한자를 사용해 공개 범위를 한정할 수 있지만 자바스크립트는 모듈 패턴을 통해 한정적으로 정보 은닉을 구현한다.
+ 캡슐화 : 객체의 프로퍼티와 메서드를 하나로 묶는 것으로 정보 은닉을 위해 사용하기도 한다.

```javascript
var Counter = (function() {
	var num = 0; // private member 가 되어 외부에서 접근할 수 없다.
	
	return { // publice member 로 외부에 노출하고 싶은 변수나 함수를 담아 객체를 생성한다.
		increase() {
			return ++num;
		},
		decrease() {
			return --num;
		}
	};
}());

console.log(Counter.num); // undefined
console.log(Counter.increase()); // 1
console.log(Counter.decrease()); // 0
```

#### 14.3.4 ES6 모듈

+ ES6 모듈을 사용하면 var 키워드로 선언한 변수는 전역변수가 아니며 window 객체의 프로퍼티도 아니다.
+ ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다.
+ script 태그에 type="module" 어트리뷰트를 추가해 사용한다.
+ 구형 브라우저에서는 동작하지 않기 때문에 모듈 번들러를 사용하는 것이 일반적이다.

<br>

<br>

# 15장 let, const 키워드와 블록 레벨 스코프

### 15.1 var 키워드로 선언한 변수의 문제점

#### 15.1.1 변수 중복 선언 허용

+ 동일한 이름의 변수가 var 키워드로 선언되어 있는 것을 모르고 변수를 중복 선언하면서 값까지 할당했다면 의도지 않게 먼저 선언된 변수의 값이 변경되는 부작용이 발생한다.
+ 초기화문(변수 선언과 동시에 초기값을 할당하는 문)이 없는 변수 선언문은 무시되고 에러도 발생하지 않는다.

#### 15.1.2 함수 레벨 스코프

+ var 키워드로 선언한 변수는 함수 레벨 스코프를 갖고 함수 외부에서 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.
+ 함수 레벨 스코프는 전역 변수를 남발할 가능성을 높인다. -> 중복 선언되는 경우가 발생

```javascript
var x = 1;

if (ture) {
	var x = 10;
}
// x는 코드블록 내에서 선언되었어도 전역변수가 되어 중복 선언된다.

console.log(x); // 10
```

#### 15.1.3 변수 호이스팅

+ var 키워드로 변수를 선언하면 스코프의 선두로 끌어올려진 것처럼 호이스팅 된다.
+ 에러가 발생하는 것은 아니지만 프로그램의 흐름상 순서가 맞지 않아 가독성을 해치고 오류를 발생시킬 여지가 있다.
+ 할당문 이전에 변수를 참조하면 undefined

<br>

### 15.2 let 키워드

#### 15.2.1 변수 중복 선언 금지

+ let 키워드로 변수를 중복 선언하면 SyntaxError 가 발생한다.

```javascript
var foo = 123;

var foo = 456; // 에러가 발생하지 않는다.

let bar = 123;

let bar = 456; // SyntaxError
```

#### 15.2.2 블록 레벨 스코프

+ let 키워드로 선언한 변수는 함수를 포함한 if 문, for 문, while 문 등을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.

```javascript
let foo = 1;

{
	let foo = 2;
	let bar = 3;
}
// 전역 변수인 foo 와 코드 블록에 있는 foo 는 별개의 변수이다.

console.log(foo); // 1
console.log(bar); // ReferenceError
// 블록 레벨 스코프를 가지는 변수 bar 는 전역에서 참조할 수 없다.
```

#### 15.2.3 변수 호이스팅

+ let 키워드로 선언한 변수는 호이스팅이 발생하지 않는 것처럼 동작한다.
+ var 키워드의 호이스팅 : 선언 + 초기화 단계가 동시에 이루어지기 때문에 변수 선언 이전에 변수에 접근해도 초기화 과정을 거쳐 undefined 를 반환한다.

```javascript
console.log(foo); // undefined
// 런타임 이전에 선언과 초기화 단계가 실행되어 undefined 를 반환한다. 선언 이전에도 참조가 가능하다.

var foo;
console.log(foo); // undefined

foo = 1;
console.log(foo); // 1
```

+ let 키워드의 호이스팅 : 선언 / 초기화 단계가 각각 이루어지기 때문에 선언 단계는 호이스팅 되고 초기화 단계는 변수 선언문에 도달했을 때 실행된다. 

```javascript
console.log(foo); // ReferenceError
// 런타임 이전에 선언 단계가 실행되지만 초기화 되지 않아 ReferenceError 가 발생한다. 
// 선언 이전에는 변수를 참조할 수 없다 -> 일시적 사각지대

let foo;
console.log(foo); // undefined
// 변수 선언문에서 초기화 단계가 실행되어 undefined 를 반환한다.

foo = 1;
console.log(foo); // 1
```

#### 15.2.4 전역 객체와 let

+ var 키워드로 선언한 전역 변수와 전역 함수, 선언하지 않은 변수에 값을 할당한 암묵적 전역은 window 의 프로퍼티가 되며 참조시 window 를 생략할 수 있다.

```javascript
var x = 1;
y = 2;
function foo() {}

console.log(x); // 1
console.log(window.x); // 1
console.log(window.y); // 2
console.log(window.foo); // f foo() {}
// 전역변수, 전역함수, 암묵적전역은 window 의 프로퍼티다.
```

+ let 키워드로 선언한 전역 변수는 보이지 않는 개념적인 블록 (전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재한다.

```javascript
let x = 1;

console.log(window.x); // undefined
console.log(x); // 1
```

<br>

### 15.3 const 키워드

#### 15.3.1 선언과 초기화

+ const 키워드로 선언한 변수는 let 과 다르게 반드시 선언과 초기화를 동시에 해야 한다.

```javascript
const foo = 1;
const foo; // SyntaxError
```

#### 15.3.2 재할당 금지

```javascript
const foo = 1;
foo = 2; // TypeError
```

#### 15.3.3 상수

+ const 키워드로 선언한 변수에 원시 값을 할당한 경우 원시 값은 변경할 수 없는 값이고 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 상수를 직접 변경하는 경우 외에는 없다.

+ 상수는 상태 유지와 가독성, 유지보수의 편의를 위해 적극적으로 사용해야 한다.
+ 상수의 이름은 대문자로 선언해 상수임을 명확히 나타내고 언더스코어로 구분해 스네이크 케이스로 표현한다.

```javascript
const TAX_RATE = 0.1;
// 쉽게 바뀌지 않고 프로그램 전체에서 고정된 값을 사용하는 경우, 상수로 선언한다.

let preTaxPrice = 100;

let afterTaxPrice = preTaxPrice + (preTaxPrice * TAX_RATE);

console.log(afterTaxPrice); // 110
```

#### 15.3.4 const 키워드와 객체

+ const 키워드로 선언된 변수에 객체를 할당한 경우 새로운 값을 재할당하는 것은 불가능 하지만 프로퍼티 동적 생성, 삭제, 변경을 통해 객체를 변경할 수 있다. 

```javascript
const person = {
	name: 'Kim'
};
// 객체 리터럴, 객체는 변경 가능한 값이다.

person.name = 'Lee';

console.log(person); // {name: "Lee"}
```

<br>

### 15.4 var vs. let vs. const

+ 변수 선언에는 기본적으로 const 를 사용하고 재할당이 필요한 경우에 한정해 let 을 사용한다.
+ ES6 를 사용한다면 var 키워드는 사용하지 않는다.
+ let 키워드를 사용할때는 스코프를 최대한 좁게 만든다.
+ 변경이 발생하지 않고 재할당이 필요없는 원시 값과 객체에는 const 키워드를 사용한다.





