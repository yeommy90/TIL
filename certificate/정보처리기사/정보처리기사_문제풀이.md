# 문제풀이



### 관계대수 & 관계해석

#### 문제1

![image-20230710103451349](./images/image-20230710103451349.png)

#### 문제2

+ R2의 A와 B를 모두 포함하는 R1의 C2를 제외한 필드를 가져와야해!!!

![image-20230710104447276](C:\Users\yeommy\AppData\Roaming\Typora\typora-user-images\image-20230710104447276.png)





### 데이터베이스

#### DDL

+ CREATE INDEX (인덱스이름) ON (테이블이름) (name asc)
+ CREATE OR REPLACE VIEW ~ AS ~
+ CREATE TRIGGER ~ AFTER INSERT ON ~ FOR EACH ROW BEGIN ~ END
+ CREATE PROCEDURE (변수 IN 변수 OUT) ~ IS ~ BEGIN ~ EXCEPTION ~ END
+ 범위분할 : PARTITION BY RANGE (컬럼)
+ 목록분할 : PARTITION BY LIST (컬럼)
+ ALTER DROP COLUMN
+ TRUNCATE

#### DCL

+ GRANT UPDATE ON ~ TO ~ WITH GRANT OPTION
+ REVOKE UPDATE ON ~ FROM ~ CASCADE

#### DML

+ cross join : 반환 가능한 모든 값
+ SELECT DISTINCT 필드명





### 페이지 교체 알고리즘

+ FIFO : 제일 먼저
+ LRU : 가장 최근
+ LFU : 빈도수

### 프로세스 스케줄링

#### FCFS

![image-20230712205402915](./images/image-20230712205402915.png)

#### SJF

+ 대기시간, 반환시간과 헷갈리지 말아라~

![image-20230712205954206](./images/image-20230712205954206.png)

+ 비선점형이기 때문에 도착순서를 바꿀수가 없다..? 논란이 있겠네요..

![image-20230712210538367](./images/image-20230712210538367.png)

#### SRT

+ 몇 초에 들어와서 몇 초에 나가는지 잘 계산하면 반환시간이 나옵니다.
+ 4초에 들어와서 5초에 나갔으면 반환시간은 1초

![image-20230712213414717](./images/image-20230712213414717.png)

#### 라운드로빈

+ 도착시간이란건 없다...

![image-20230712231851588](./images/image-20230712231851588.png)

+ P1의 실행시간 중 P2, P3, P4가 들어오면 상관없는데 실행 종료 후 대기큐에 들어간 이후에 들어오면 순서 바꿔줘야 합니다!!!

<img src="./images/image-20230715173026071.png" alt="image-20230715173026071" style="zoom:50%;" />







### 디스크 스케줄링

#### C-SCAN

+ 35에서 47로 이동 > 바깥쪽으로 나가면서 처리 중
+ 맨 끝까지 갔다가 다시 맨 처음으로 가서 바깥쪽으로 나감

![image-20230721154926865](./images/image-20230721154926865.png)



### 서브넷

#### 서브넷 마스크

+ 서브넷 개수는 -2 하지말고, 호스트 개수는 -2 해야한다

+ 26로 나누려면 최소 2^5개, 11111000 > 248이 된다!

![image-20230719183209927](./images/image-20230719183209927.png)

+ B주소는 2개의 옥텟을 사용, 서브넷은 2^12 - 2, 호스트는 2^4 - 2

![image-20230719183835207](./images/image-20230719183835207.png)

+ 192니까 2개의 비트, 총 네개의 서브넷으로 나누어짐
+ 00, 01, 10, 11 >>>>> 세번째인 128~191 사이 네트워크이고, 맨 마지막은 브로드캐스트 IP니까 제외, 190

![image-20230719204303653](./images/image-20230719204303653.png)





### C언어

#### 배열

+ char str[] = "abcde"; >>>>> 암묵적으로 뒤에 빈 공간 하나 있음 >>>>> 6
+ int num[] ={1,2,3,4,5}; >>>>> 4byte씩 다섯개 >>>>> 20

![image-20230710203944691](./images/image-20230710203944691.png)

#### 포인터

+ *&pt >>>>> pt의 주소가 가진 값, pt가 참조중인 주소 그 자체

![image-20230710210226537](./images/image-20230710210226537.png)

+ *p + 2 >>>>> p의 값은 K니까 K에 2를 더한 값 >>>>> M

![image-20230710210658445](./images/image-20230710210658445.png)

+ 선증가, 후증가 제대로 체크!!

![image-20230711210937114](./images/image-20230711210937114.png)

+ ary + 1 >>>>> 주소값에 1을 더했기 때문에 이상한 숫자 나옴 >>>>>주소값 그 자체가 출력

![image-20230711211824484](./images/image-20230711211824484.png)

+ 2차원 배열은 p+1하게되면 다음 행으로 넘어간다...





#### 포인터 배열

+ 주소값을 배열에 저장, 연속되는 개념이 아님 >>>>> bbb

![image-20230711213332369](./images/image-20230711213332369.png)

 



#### 함수

+ x의 주소값 + 1을 한 후 그 자리의 주소값의 값에 2를 곱한것...!

![image-20230717195336369](./images/image-20230717195336369.png)



+ fork() : 부모 프로세스 실행 후, 자식 프로세스 그대로 실행 >>>>> 2번 실행
+ 부모 프로세스는 0 이상, 자식 프로세스는 0, 실패했으면 -1

![image-20230717200530926](./images/image-20230717200530926.png)

+ 무조건 부모 먼저 실행되는데, wait를 만나면 자식 먼저~

![image-20230717201722012](./images/image-20230717201722012.png)

+ 실행중인 프로세스는 2^3, 새로 생긴 프로세스는 2^3-1

![image-20230717202256063](./images/image-20230717202256063.png)

#### 재귀함수

+ 프린트문과 함수 위치 잘 보세요...

![image-20230718111258002](./images/image-20230718111258002.png)



#### printf

+ int i = 5;

+ printf("%d, %d, %d, %d", i++, ++i, i++, ++i) >>>>> 8 9 6 9
+ printf는 뒤에서부터 연산을 시작
+ 연산을 만나기 전까지 어떤 값을 출력할지 알 수 없음....@@



### ++

+ int i = 5;
+ int z = ++i + ++i + ++i; >>>>> 7+7+8
+ +를 만나야 i가 결정된다...........



#### 콤마(,) 연산자

+ int a = ( 10, 20 ) >>>>> a = 20

+ 맨 뒤의 값 출력







### 파이썬

#### SET

+ 중복 허용 안함

![image-20230718162859678](./images/image-20230718162859678.png)



#### 반복문

+ for i in range(1, 3) >>>>> 1에서 2까지 돈다
+ a의 값은 바뀐적이 없으니 2번째 반복에서도 그대로 100을 유지

![image-20230719102717637](./images/image-20230719102717637.png)

#### 문자열 출력

+ %s >>>>> C언어와 똑같이 생각해라

![image-20230719155746375](./images/image-20230719155746375.png)

+ 배열 출력할 때는 [] 빼놓지 말아라~

![image-20230720212716398](./images/image-20230720212716398.png)





### 자바

#### 상속, 오버라이딩, 하이딩

+ 메서드 하이딩...? : static으로 정의된 메서드는 클래스에 속한 메서드로 부모 클래스와 자식 클래스의 메서드는 완전히 독립적인 메서드로 취급된다.
+ 오버라이딩 된 메소드는 부모 클래스가 가려지지만, 같은 이름의 필드를 정의한 경우 가려지지 않고 각각 클래스의 변수로 존재하게 된다. 그래서 부모 타입으로 객체를 생성하면 부모의 필드가, 자식 타입으로 객체를 생성하면 자식의 필드가 호출된다.

![image-20230720201624360](./images/image-20230720201624360.png)

#### 문법

+ 문자열 만난 순간부터 문자열 취급...바부야..

![image-20230720210658495](./images/image-20230720210658495.png)











































