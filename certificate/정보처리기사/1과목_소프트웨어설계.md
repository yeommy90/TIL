# 1 소프트웨어 설계

## 1.1 소프트웨어

+ 소프트웨어의 개념 : 프로그램, 자료구조, 문서
+ 소프트웨어의 특징 : 상품성, 복잡성, 변경가능성, 복제성
+ 시스템의 개요와 기본 요소 : 입력-처리-출력-제어-피드백
+ 소프트웨어 위기
  - 소프트웨어의 개발 속도가 하드웨어의 개발 속도를 따라가지 못함
  - 원인 : 하드웨어 비용을 초과하는 개발 비용의 증가, 개발 기간의 지연, 개발 인력 부족 및 인건비 상승, 성능 및 신뢰성 부족, 유지보수의 어려움에 따른 엄청난 비용

## 1.2 소프트웨어 공학

+ 소프트웨어 공학 : 경제적으로 신뢰도 높은 소프트웨어를 만들기 위한 방법, 도구와 절차들의 체계
+ 소프트웨어 공학의 기본 원칙 : 현대적 프로그래밍 기술 사용, 높은 신뢰성, 편리성과 유지보수성, 지속적 검증 시행

<br>

<br>

<br>

# 2 재공학

## 2.1 재공학

+ 소프트웨어 재공학의 개념 : 소프트웨어 위기를 개발의 생산성이 아닌 유지보수의 생산성으로 해결하려는 방법, 유지보수성 향상과 재사용
+ 재공학의 과정 : 분석 -> 구성(구조변경) -> 역공학 -> 이식

## 2.2 역공학

+ 역공학의 개념 : 소프트웨어를 분석해 재문서화

## 2.3 CASE

+ CASE : 소프트웨어 엔지니어링을 도와주는 자동화 도구
+ 기능 : 신속 개발, 생명주기 연결, 자동화, 그래픽 기능, 자료 흐름도 작성 기능, 모순 검사 기능
+ 원천 기술 : 구조적 기법, 프로토타이핑 기술, 정보 저장소 기술
+ 장점 : 비용 절약, 유지보수 간편, 품질 향상, 문서화의 용이성
+ 상위 (요구분석 설계) 하위 (실제 구현, 코딩) 통합 (개발 주기 전체 과정 지원)
+ CASE 도구 : SADT(구조적 설계도구, 블록 다이어그램 채택)

<br>

<br>

<br>

# 3 소프트웨어 개발 방법론

## 3.1 소프트웨어 설계 방법론

+ 소프트웨어 생명주기 : 타당성 검토 - 개발 계획 - 요구사항 분석 - 설계 - 구현 - 테스트 - 운용 - 유지보수
+ 폭포수 모형 : 고전적 생명주기 모형, 소규모 적합, 이벤트 발생시 적용 불가
+ 나선형 모형 : Boehm, 점증적 생명주기 모형, 계획 수립 - 위험분석 - 개발 및 검증 - 고객평가
+ 하향식 설계 : 뿌리를 만들고 곁가지
+ 상향식 설계 : 컴포넌트를 모아서 기둥을 세워
+ HIPO : 입력, 처리, 출력으로 구성되는 설계화 문서화 기법, 가시적 도표, 총체적 다이어그램, 세부적 다이어그램, 하향식 소프트웨어 개발을 위한 문서화 도구
+ V-모델
  - 폭포수 모형에 시스템 검증과 테스트 작업을 강조한 모델, 단위별로 테스트
  - 요구사항 분석 : 인수 테스트
  - 기능명세 분석 : 시스템 테스트
  - 설계 : 통합 테스트
  - 개발 : 단위 테스트
  - 테스트 계획 및 설계(정적) : 테스트 수행(동적)

## 3.2 애자일 개발 방법론

+ 애자일 개발 방법론 : 날렵한, 재빠른, 고객과의 협업에 초점을 두고 신속히 대응
+ 애자일 종류 : 익스트림프로그래밍, 스크럼, 린, DSDM, FDD, Crystal, ASD

## 3.3 익스트림프로프래밍 (XP)

+ XP : Kent Beck, 빠르게 양질의 소프트웨어, 소통, 단순성, 피드백, 용기, 존중
+ XP Process : Spike(요구사항 확인) - 배포계획 - 테스트반복 - 소규모배포, 고객이 만족할때까지 테스트 반복!!
+ 실천사항 : 짝프로그래밍(개발/테스트), 플래닝게임, 테스트드라이븐개발, 홀팀(고객을 프로젝트 팀원으로), 상시배포, 디자인발전, 소규모배포, 코딩표준
+ 3대 요소 : 인적 자원, 문제 인식, 작업 계획 (People, Problem, Process)

<br>

<br>

<br>

# 4 스크럼

## 4.1 SCRUM

+ 스크럼의 개념과 특징 : 요구사항 변경에 신속대처, 팀 중심의 소통과 협동심, 스프린트, 소멸차트
+ 스크럼팀의 역할 : 제품 책임자(개발 의뢰자), 스크럼 마스터(업무 배분), 스크럼 팀(팀원)

## 4.2 스크럼 과정

+ Product Backlog, Sprint, Sprint Planning Meeting, Daily SCRUM Meeting, Finished Work, Review, Retrospective

<br>

<br>

<br>

# 5 현행 시스템 분석

## 5.1 현행 시스템 분석

+ 현행 시스템 분석의 정의와 목적 : 어떤 하위 시스템으로 구성되어 있는지 파악
+ 현행 시스템 파악 절차 : 시스템 구성,기능,인터페이스 파악 -> 아키텍쳐 파악 소프트웨어 구성 파악 -> 시스템 하드웨어 현황 파악 네트워크 구성 파악
+ 시스템 아키텍쳐 : 조직의 설계도, 시스템 내의 상위 시스템과 하위 시스템들이 어떤 관계로 상호작용하는지 각각의 동작 원리와 구성을 표현한 것, 단위 업무 시스템별로 아키텍처가 다른 경우 핵심 기간 업무 처리 시스템을 기준

## 5.2 시스템 및 인터페이스 현황 파악

+ 시스템 구성 파악 : 기간 업무 / 지원 업무

+ 시스템 기능 파악 : 주요 기능 / 하부 기능
+ 인터페이스 현황 파악 : 데이터 형식, 통신 규약, 연계 유형
+ EAI : 기업 애플리케이션 통합
+ FEP : 전위 처리기

## 5.3 소프트웨어, 하드웨어, 네트워크 현황 파악

+ 소프트웨어 구성 파악 : 라이선스 파악
+ 하드웨어 구성 파악 : 컴퓨터 사양, 서버 이중화

## 5.4 플랫폼

+ 플랫폼 : 응용 소프트웨어 + (하드웨어 + 시스템 소프트웨어), JAVA, .NET, IOS, 안드로이드, 윈도우
+ 플랫폼 성능 특성 분석 : 응답 시간, 가용성, 사용률
+ 플랫폼 성능 특성 분석 방법 : 기능 테스트, 사용자 인터뷰, 문서 점검

## 5.5 현행 시스템의 OS 분석

+ 현행 시스템의 OS 분석 항목 및 고려사항
  - 분석 항목 : OS 종류와 버전, 패치 일자, 백업 주기 분석
  - 고려사항 : 가용성, 성능, 기술 지원, 주변기기, 구축 비용(TCO)
  - 메모리 누수
+ 오픈소스 라이선스 종류
  - GNU : 모든 정보를 돈으로 구매하는 것을 반대, 리눅스
  - GNU GPLv1 : 바이너리만 배포하는 것을 금지하며 쉬운 소스 코드를 같이 배포해야 한다.
  - BSD : 아무나 수정, 배포할 수 있고 상용 소프트웨어에도 사용 가능
  - Apache 2.0 : 안드로이드, HADOOP(다수의 저렴한 컴퓨터를 묶어 빅데이터를 처리)

## 5.6 현행 시스템 DBMS 분석

+ DBMS : 종속성과 중복성의 문제를 해결하기 위한 데이터베이스 시스템
+ 현행 시스템 DBMS 분석 : 종류, 버전 등
+ DBMS 분석 시 고려사항 : 가용성, 성능, 기술 지원, 상호 호환성, 구축 비용

<br>

<br>

<br>

# 6 요구사항 개발

## 6.1 요구사항 개발

+ 요구공학 : 자료 흐름도, 자료 사전, 소단위 명세서로 구축

+ 요구공학의 목적 : 원활한 의사소통, 요구사항 누락 방지, 상호 이해 오류 제거, 요구사항 정의 문서화

+ 요구사항 베이스라인 : 명시적 합의 내용

+ 요구공학 프로세스 : 경제성, 기술성, 적법성, 대안성 등 타당성 조사 선행

+ SWEBOK(표준화 체계 문서)에 따른 요구사항 개발 프로세스 : 도출 - 분석 - 명세 - 확인

+ 요구사항 도출
  - 문제 해결 이해, 파악, 목표 도출
  - 요구사항 도출 기법 : 고객의 발표, 문서 조사, 설문, 업무 절차 조사, 브레인스토밍, 워크숍, 인터뷰, 프로토타이핑, Use Case, 벤치마킹, BPR(업무재설계), RFP(제안요청서)
  
+ 요구사항 분석

  - 요구사항을 걸러 내는 과정, 사용자 의견 청취, 사용자 인터뷰, 현재 사용중인 문서분석, 관찰 모델 작성 기술, 설문 조사를 통한 의견 수립

  - 수행 단계 : 문제 인식 - 전개 - 평가와 종합 - 검토 - 문서화

  - 분류 기준 : 기능 요구사항(실제 동작) / 비기능 요구사항(성능, 보안, 품질, 안정성)

+ 요구사항 명세
  - 정형 명세 : 수학적/모델링 기반 / Z, VDM, Petri-new, LOTOS, CSP, CCS / 정확 간결 / 낮은 이해도
  - 비정형 명세 : 객체/자연어 기반 / FSM, Decision Table, ER 모델링, State Chart, UseCase, 사용자 기반 / 이해 용이 다양 / 모호성 불충분한 명세 기능
  
  - 속성 : 정확성, 명확성, 완전성, 일관성, 수정 용이성
  
+ 요구사항 확인 : 표준에 적합한가, 이해 가능한가, 일관성 있는가, 완전한가

+ 요구사항 관리 도구의 필요성 : 비용 편익 분석, 변경의 추적, 변경에 따른 영향 평가

+ 형상 관리 : 애플리케이션 개발 단계에서 문서, 데이터 등의 모든 자료의 변경을 관리

+ 정형 분석 : 정확하고 명확하게 표현

## 6.2 요구사항 확인 기법

+ 프로토타이핑 : 시제품 제작, 새로운 요구사항 도출
+ 모델 검증 : 정적 분석(객체 모델에서 의사소통 경로) / 동적 분석(직접 실행)
+ 인수 테스트 : 계약 인수 테스트, 규정 인수 테스트, 알파 검사, 베타 검사, 사용자 인수 테스트, 운영 인수 테스트 
+ 요구사항 검토

<br>

<br>

<br>

# 7 UML

## 7.1 개념 모델링

+ 개념 모델링 종류 : Use Case Diagram, Data Flow Model, State Model, Goal-Based Model, User Interactions, Object Model, Data Model

## 7.2 UML (Unified Modeling Language)

+ UML : 객체지향 소프트웨어 개발 과정에서 사용하는 범용 모델링 언어, 럼바우(OMT) + Booch(Booch) + Jacobson(OOSE)
+ 럼바우 객체지향 분석 기법
  - 객체 모델링 : 객체 다이어그램
  - 동적 모델링 : 상호작용 등의 상태를 상태 다이어그램
  - 기능 모델링 : 자료 흐름
+ UML 의 특성 : 비주얼화, 문서화, 명세화, 구축
+ UML 소프트웨어에 대한 관점 : 기능적 관점(사용자 측면), 정적 관점(구조적), 동적 관점(내부 동작)
+ UML 의 기본 구성 : 사물, 관계, 다이어그램
+ 스테레오 타입 : 길러멧(<<>>) 확장 요소
+ UML 접근 제어자 : Public(+), Private(-), Protected(#), Package(~)

## 7.3 UML 다이어그램의 분류

+ 구조적 다이어그램 : 클래스, 객체, 복합체 구조, 배치, 컴포넌트, 패키지 다이어그램
+ 행위 다이어그램 : 유스케이스, 활동, 상태 머신, 콜라보레이션, 순차, 상호작용, 통신, 타이밍 다이어그램

## 7.4 클래스 다이어그램 관계 표현

+ 클래스 다이어그램 : 객체 간의 관계를 추상화, 클래스 이름, 속성, 메소드
+ UML 관계 표현 : 단방향, 양방향, 의존(-->), 일반화(-삼각형, 상속), 집합(-마름모), 실체화(--삼각형) 
+ UML 연관 관계 : 클래스가 연관 있다면 서로 참조 가능

+ UML 의존 관계 : 메소드
+ UML 일반화 관계 : 상속 (차-버스,택시)
+ UML 집합 관계 : A 객체가 B 객체에 포함된 관계 (빈 마름모)
+ UML 포함 관계 : 부분이 전체에 속하는 강한 집합 연관의 관계 (찬 마름모)
+ UML 실체화 관계 : 인터페이스와 클래스 간의 관계, 의무적 관계

## 7.5 Use Case Diagram

+ Use Case Diagram 의 개념 : 사용자의 요구를 기능적 측면에서 기술
+ 요소 : 시스템 경계(행위), 액터, 유스케이스, 접속 관계, 사용 관계, 확장 관계
+ 작성 단계 : 액터식별, 유즈케이스식별, 관계 정의, 구조화

<br>

<br>

<br>

# 8 소프트웨어 아키텍쳐

## 8.1 소프트웨어 아키텍쳐

+ 소프트웨어 아키텍쳐 : 구조, 설계도, 요구사항 만족
+ ISO/IEC 9126 모델 : 소프트웨어 품질 특성과 평가를 위한 국제 표준
  - 내외부 품질 : 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성
  - 사용 품질 : 효과성, 생산성, 안정성, 만족도
  - 외부 지표, 내부 지표
+ ISO/IEC 25010 모델 : 위에꺼에서 2개 추가

## 8.2 UI 표준을 위한 환경 분석

+ 사용자 경향 분석 : 연령대, 요구사항, 기능위주
+ 기능 및 설계 분석 : 기능 조작성, 오류방지, 최소한의 조작으로 업무 처리 가능한 형태 분석, UI 정보전달력 확인
+ 요구사항 요소 : 데이터 요구, 기능 요구, 제품서비스 품질, 제약 사항
+ 정황 시나리오 작성 : 서비스의 초기 모양, 육하원칙, 간단명료

<br>

<br>

<br>

# 9 UI 표준 및 지침

## 9.1 UI 표준 및 지침

+ User Interface : 상호작용에 필요한 화상, 문자, 소리, 수단
+ 분야 : 표현, 정보제공, 기능
+ 특징 : 실사용자의 만족도, 아키텍쳐 숙지
+ UI 개발 시스템이 가져야 할 기능 : 입력 검증, 에러 처리, 도움과 프롬프트

## 9.2 UI 설계

+ UI 설계 원칙 : 직관성, 유효성, 학습성, 유연성
+ 설계 지침 : 사용자 중심, 일관성, 단순성, 가시성, 표준화, 접근성, 결과예측가능, 명확성, 오류발생해결

## 9.3 UI 표준

+ UI 구현 표준 : 공통 화면 구성 등
+ 한국형 웹 콘텐츠 접근성 지침 : 인식의 용이성, 운용의 용이성, 이해의 용이성, 견고성

## 9.4 UX

+ User eXperience : 성능, 시간, 감성 공학
+ 모바일 사용자 고려사항 : 직관적, 입력 최소화, 되돌림

<br>

<br>

<br>

# 10 UI 설계

## 10.1 UI 설계 단계

+ UI 설계 단계 : 문제 정의, 사용자 모델 정의, 작업 분석, 오브젝트 기능 정의, UI 정의, 디자인 평가(GOMS, Heuristics)
+ 상세 설계 단계 : UI 메뉴 구조 설계, 내외부 화면과 폼설계, UI 검토수행
+ 시나리오 작성 원칙 : 트리구조나 플로우차트 표기법을 이용한다. 완전성, 일관성, 이해성, 가독성, 수정 용이성, 추적 용이성

## 10.2 UI 설계 도구

+ 와이어프레임 : 레이아웃을 선을 이용해 개략적으로 작성, 핸드라이팅, 파워포인트, 키노트, 스케치, 카카오 오븐
+ 목업(Mockup) : 실물과 흡사한 정적 모형(스마트폰), 발사믹 목업, 파워 목업, 카카오 오븐
+ 프로토타입 : 상호작용이 결합한 실제 작동 모형
+ 스토리보드 : 설계 문서, 개발자-디자이너와의 의사소통을 돕는 도구

## 10.3 UI 프로토타입

+ 프로토타입 : HTML, Axure, 카카오 오븐, Flinto, 네이버 프로토 나우
+ 장단점 : 사용자 중심, 개발 시간 감소, 오류 방지 / 수정이 많아지면 힘들어, 자원 소모, 문서 작업 생략

## 10.4 감성 공학

+ 감성 공학 : 1류(의미 미분법, 감각, 감성) / 2류(+상활 양식) / 3류(특정 시제품)
+ 감성 공학 요소 기술 : 기초 기술, 구현 기술, 응용 기술

<br>

<br>

<br>

# 11 소프트웨어 설계 모델링

## 11.1 소프트웨어의 설계

+ 소프트웨어 설계 모델링 : 무엇을 어떻게 만들것인가
+ 소프트웨어 설계 분류
  - 상위 : 아키텍쳐 설계, 데이터 설계, 인터페이스 정의, 사용자 인터페이스 설계
  - 하위 : 모듈 설계, 자료 구조 설계, 알고리즘 설계
+ 상위 설계 : 예비, 뼈대 / 하위 설계 : 상세
+ 소프트웨어 설계 대상 : 구조 모델링 (컴포넌트, 모듈, 내부 설계 구조), 행위 모델링 (기능 수행, 상호작용, 데이터)
+ 소프트웨어 설계 방법 : 구조적 설계(Coad, Yourdon), 자료 중심 설계(Jackson Warner-Orr), 객체지향 설계(추상화, Rumbaugh, Sheller/Meller)
+ 소프트웨어 구조도
  - Fan-in : 위에서 들어오는 구조, 재사용 측면에서 잘된 설계, 단일 장애 발생 가능성, 중점 관리
  - Fan-out : 아래로 나가는 구조, 단순 설계 해야함

## 11.2 코드 설계의 개요

+ 코드의 기능
  - 기본 기능 : 표준화, 간소화 기능
  - 3대 기능 : 분류, 식별, 배열 기능
  - 부가적 기능 : 연상, 암호화, 오류 검출 기능

## 11.3 코드의 종류

+ 순차 코드 : 일련번호, 항목이 적고 변경이 적은 자료, 누락된 번호 삽입이 어려움
+ 블록 코드 : 각 블록 안에서 일련번호 배정
+ 그룹 분류식 코드 : 대분류, 중분류, 소분류
+ 10진 분류 코드 : 도서 분류 코드
+ 표의 숫자 코드 : 대상 항목의 길이, 넓이, 무게 등을 나타내는 문자나 숫자 (127-890-1245 두께-폭-길이)
+ 연상 코드(기호 코드) : 품목 명칭 일부를 약호 형태로 배정 (TV-39-C TV 39인치 컬러)
+ 오류 종류 : 필사(한자리 잘못), 전위(좌우 바꿈), 이중(전위 2개), 생략, 추가, 임의(두가지 이상)

## 11.4 구조적 개발 방법론

+ 구조적 분석 : 자료의 흐름을 중심으로 전체 시스템의 일관성 있는 이해를 돕는 분석 도구, 체계적, 정형화, 문서화, 자료 사전, 소단위 명세

+ 자료 흐름도(DFD)
  - 버블 차트, 4가지 기본 기호
  - 프로세스 : 시스템의 한 부분, 동그라미
  - 자료 흐름 : 자료의 이동, ->
  - 자료 저장소(Data store) : 파일, 데이터베이스, 위아래 밑줄
  - 단말 : 입력과 출력, 네모
+ 소단위 명세서
  - 최하위 단계 버블의 처리 절차를 기술, 프로세스 명세서
  - 구조적 언어, 의사 결정 나무, 의사 결정표
+ 자료 사전
  - = (정의), + (연결), () (생략), | (or), {}n (n 번이상반복), * * (주석)
  - 자료 항목, 자료 저장소, 자료에 대한 의미, 자료 원소의 단위 및 값

<br>

<br>

<br>

# 12 모듈

## 12.1 모듈과 결합도, 응집도

+ 모듈 : 재사용과 컴파일 가능, 독립성
+ 결합도
  - 서로 다른 두 묘듈간의 상호 의존도, 낮을수록 독립성이 향상되어 유지보수가 쉬워짐
  - 자료 결합도 : 모듈 간 인터페이스가 자료 요소로만 구성, 모듈 간 영향을 주지 않음
  - 스탬프 결합도 : 같은 자료 구조를 조회, 배열, 레코드
  - 제어 결합도 : 제어 신호
  - 외부 결합도 : 외부로 선언한 변수를 참조
  - 공통 결합도 : 여러 모듈이 공통 자료 영역을 사용
  - 내용 결합도 : 내부 기능 및 내부 자료를 참조
+ 응집도
  - 모듈 안의 요소들이 서로 관련된 정도, 높을 수록 필요한 요소들로 구성됨
  - 기능적 응집도 : 기능 요소들이 한 문제와 연관
  - 순차적 응집도 : 다음 기능 요소의 입력 자료로 제공
  - 교환적 응집도 : 같은 입출력 사용
  - 절차적 응집도 : 다수의 관련 기능이 순차적 수행
  - 시간적 응집도 : 특정 시간에 처리되는 기능
  - 논리적 응집도 : 유사, 특정 형태로 분류되는 요소
  - 우연적 응집도 : 관련 없는 요소
+ 모듈 설계의 특징 : 결합도는 낮게, 응집도는 높게

## 12.2 모듈과 컴포넌트

































