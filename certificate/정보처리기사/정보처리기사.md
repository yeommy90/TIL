# 1 소프트웨어 설계

## 1.1 소프트웨어

+ 소프트웨어의 개념 : 프로그램, 자료구조, 문서
+ 소프트웨어의 특징 : 상품성, 복잡성, 변경가능성, 복제성
+ 시스템의 개요와 기본 요소 : 입력-처리-출력-제어-피드백
+ 소프트웨어 위기
  - 소프트웨어의 개발 속도가 하드웨어의 개발 속도를 따라가지 못함
  - 원인 : 하드웨어 비용을 초과하는 개발 비용의 증가, 개발 기간의 지연, 개발 인력 부족 및 인건비 상승, 성능 및 신뢰성 부족, 유지보수의 어려움에 따른 엄청난 비용

## 1.2 소프트웨어 공학

+ 소프트웨어 공학 : 경제적으로 신뢰도 높은 소프트웨어를 만들기 위한 방법, 도구와 절차들의 체계
+ 소프트웨어 공학의 기본 원칙 : 현대적 프로그래밍 기술 사용, 높은 신뢰성, 편리성과 유지보수성, 지속적 검증 시행

<br>

<br>

<br>

# 2 재공학

## 2.1 재공학

+ 소프트웨어 재공학의 개념 : 소프트웨어 위기를 개발의 생산성이 아닌 유지보수의 생산성으로 해결하려는 방법, 유지보수성 향상과 재사용
+ 재공학의 과정
  - 분석 : 재공학 대상을 선정
  - 구성(구조변경) : 기존 소프트웨어의 향상을 위해 코드를 재구성
  - 역공학 : 기존 소프트웨어를 분석해 소스코드를 얻어내는 작업
  - 이식 : 다른 운영체제나 하드웨어에서 사용할 수 있도록 변환하는 작업

## 2.2 역공학

+ 역공학의 개념 : 소프트웨어를 분석해 재문서화

## 2.3 CASE

+ CASE : 소프트웨어 엔지니어링을 도와주는 자동화 도구
+ 기능 : 신속 개발, 생명주기 연결, 자동화, 그래픽 기능, 자료 흐름도 작성 기능, 모순 검사 기능
+ 원천 기술 : 구조적 기법, 프로토타이핑 기술, 정보 저장소 기술
+ 장점 : 비용 절약, 유지보수 간편, 품질 향상, 문서화의 용이성
+ 상위 (요구분석 설계) 하위 (실제 구현, 코딩) 통합 (개발 주기 전체 과정 지원)
+ CASE 도구 : SADT(구조적 설계도구, 블록 다이어그램 채택)

<br>

<br>

<br>

# 3 소프트웨어 개발 방법론

## 3.1 소프트웨어 설계 방법론

+ 소프트웨어 생명주기 : 타당성 검토 - 개발 계획 - 요구사항 분석 - 설계 - 구현 - 테스트 - 운용 - 유지보수
+ 폭포수 모형 : 고전적 생명주기 모형, 소규모 적합, 이벤트 발생시 적용 불가
+ 나선형 모형 : Boehm, 점증적 생명주기 모형, 계획 수립 - 위험분석 - 개발 및 검증 - 고객평가
+ 하향식 설계 : 뿌리를 만들고 곁가지
+ 상향식 설계 : 컴포넌트를 모아서 기둥을 세워
+ HIPO : 입력, 처리, 출력으로 구성되는 설계화 문서화 기법, 가시적 도표, 총체적 다이어그램, 세부적 다이어그램, 하향식 소프트웨어 개발을 위한 문서화 도구
+ V-모델
  - 폭포수 모형에 시스템 검증과 테스트 확인을 강조한 모델, 단위별로 테스트
  - 요구사항 분석 : 인수 테스트
  - 기능명세 분석 : 시스템 테스트
  - 설계 : 통합 테스트
  - 개발 : 단위 테스트
  - 테스트 계획 및 설계(정적) : 테스트 수행(동적)

## 3.2 애자일 개발 방법론

+ 애자일 개발 방법론 : 날렵한, 재빠른, 고객과의 협업에 초점을 두고 신속히 대응
+ 애자일 종류 : 익스트림프로그래밍, 스크럼, 린, DSDM, FDD, Crystal, ASD

## 3.3 익스트림프로프래밍 (XP)

+ XP : Kent Beck, 빠르게 양질의 소프트웨어, 소통, 단순성, 피드백, 용기, 존중
+ XP Process : Spike(요구사항 확인) - 배포계획 - 테스트반복 - 소규모배포, 고객이 만족할때까지 테스트 반복!!
+ 실천사항 : 짝프로그래밍(개발/테스트), 플래닝게임, 테스트드라이븐개발, 홀팀(고객을 프로젝트 팀원으로), 상시배포, 디자인발전, 소규모배포, 코딩표준
+ 3대 요소 : 인적 자원, 문제 인식, 작업 계획 (People, Problem, Process)

<br>

<br>

<br>

# 4 스크럼

## 4.1 SCRUM

+ 스크럼의 개념과 특징 : 요구사항 변경에 신속대처, 팀 중심의 소통과 협동심, 스프린트, 소멸차트
+ 스크럼팀의 역할 : 제품 책임자(개발 의뢰자), 스크럼 마스터(업무 배분), 스크럼 팀(팀원)

## 4.2 스크럼 과정

+ Product Backlog, Sprint, Sprint Planning Meeting, Daily SCRUM Meeting, Finished Work, Review, Retrospective

<br>

<br>

<br>

# 5 현행 시스템 분석

## 5.1 현행 시스템 분석

+ 현행 시스템 분석의 정의와 목적 : 어떤 하위 시스템으로 구성되어 있는지 파악
+ 현행 시스템 파악 절차 : 시스템 구성,기능,인터페이스 파악 -> 아키텍쳐 파악 소프트웨어 구성 파악 -> 시스템 하드웨어 현황 파악 네트워크 구성 파악
+ 시스템 아키텍쳐 : 조직의 설계도, 시스템 내의 상위 시스템과 하위 시스템들이 어떤 관계로 상호작용하는지 각각의 동작 원리와 구성을 표현한 것, 단위 업무 시스템별로 아키텍처가 다른 경우 핵심 기간 업무 처리 시스템을 기준

## 5.2 시스템 및 인터페이스 현황 파악

+ 시스템 구성 파악 : 기간 업무 / 지원 업무

+ 시스템 기능 파악 : 주요 기능 / 하부 기능
+ 인터페이스 현황 파악 : 데이터 형식, 통신 규약, 연계 유형
+ EAI : 기업 애플리케이션 통합
+ FEP : 전위 처리기

## 5.3 소프트웨어, 하드웨어, 네트워크 현황 파악

+ 소프트웨어 구성 파악 : 라이선스 파악
+ 하드웨어 구성 파악 : 컴퓨터 사양, 서버 이중화

## 5.4 플랫폼

+ 플랫폼 : 응용 소프트웨어 + (하드웨어 + 시스템 소프트웨어), JAVA, .NET, IOS, 안드로이드, 윈도우
+ 플랫폼 성능 특성 분석 : 응답 시간, 가용성, 사용률
+ 플랫폼 성능 특성 분석 방법 : 기능 테스트, 사용자 인터뷰, 문서 점검

## 5.5 현행 시스템의 OS 분석

+ 현행 시스템의 OS 분석 항목 및 고려사항
  - 분석 항목 : OS 종류와 버전, 패치 일자, 백업 주기 분석
  - 고려사항 : 가용성, 성능, 기술 지원, 주변기기, 구축 비용(TCO)
  - 메모리 누수
+ 오픈소스 라이선스 종류
  - GNU : 모든 정보를 돈으로 구매하는 것을 반대, 리눅스
  - GNU GPLv1 : 바이너리만 배포하는 것을 금지하며 쉬운 소스 코드를 같이 배포해야 한다.
  - BSD : 아무나 수정, 배포할 수 있고 상용 소프트웨어에도 사용 가능
  - Apache 2.0 : 안드로이드, HADOOP(다수의 저렴한 컴퓨터를 묶어 빅데이터를 처리)

## 5.6 현행 시스템 DBMS 분석

+ DBMS : 종속성과 중복성의 문제를 해결하기 위한 데이터베이스 시스템
+ 현행 시스템 DBMS 분석 : 종류, 버전 등
+ DBMS 분석 시 고려사항 : 가용성, 성능, 기술 지원, 상호 호환성, 구축 비용

<br>

<br>

<br>

# 6 요구사항 개발

## 6.1 요구사항 개발

+ 요구공학 : 자료 흐름도, 자료 사전, 소단위 명세서로 구축
+ 요구공학의 목적 : 원활한 의사소통, 요구사항 누락 방지, 상호 이해 오류 제거, 요구사항 정의 문서화
+ 요구공학 프로세스 : 경제성, 기술성, 적법성, 대안성 등 타당성 조사 선행
+ SWEBOK(표준화 체계 문서)에 따른 요구사항 개발 프로세스 : 도출 - 분석 - 명세 - 확인
+ 요구사항 도출
  - 문제 해결 이해, 파악, 목표 도출
  - 요구사항 도출 기법 : 고객의 발표, 문서 조사, 설문, 업무 절차 조사, 브레인스토밍, 워크숍, 인터뷰, 프로토타이핑, Use Case, 벤치마킹, BPR(업무재설계), RFP(제안요청서)
+ 요구사항 분석

  - 요구사항을 걸러 내는 과정, 사용자 의견 청취, 사용자 인터뷰, 현재 사용중인 문서분석, 관찰 모델 작성 기술, 설문 조사를 통한 의견 수립

  - 수행 단계 : 문제 인식 - 전개 - 평가와 종합 - 검토 - 문서화

  - 분류 기준 : 기능 요구사항(실제 동작) / 비기능 요구사항(성능, 보안, 품질, 안정성)
+ 요구사항 명세
  - 정형 명세 : 수학적/모델링 기반 / Z, VDM, Petri-new, LOTOS, CSP, CCS / 정확 간결 / 낮은 이해도
  - 비정형 명세 : 객체/자연어 기반 / FSM, Decision Table, ER 모델링, State Chart, UseCase, 사용자 기반 / 이해 용이 다양 / 모호성 불충분한 명세 기능
  
  - 속성 : 정확성, 명확성, 완전성, 일관성, 수정 용이성
+ 요구사항 확인 : 표준에 적합한가, 이해 가능한가, 일관성 있는가, 완전한가
+ 요구사항 관리 도구의 필요성 : 비용 편익 분석, 변경의 추적, 변경에 따른 영향 평가
+ 형상 관리 : 애플리케이션 개발 단계에서 문서, 데이터 등의 모든 자료의 변경을 관리
+ 정형 분석 : 정확하고 명확하게 표현

## 6.2 요구사항 확인 기법

+ 프로토타이핑 : 시제품 제작, 새로운 요구사항 도출
+ 모델 검증 : 정적 분석(객체 모델에서 의사소통 경로) / 동적 분석(직접 실행)
+ 인수 테스트 : 계약 인수 테스트, 규정 인수 테스트, 알파 검사, 베타 검사, 사용자 인수 테스트, 운영 인수 테스트 
+ 요구사항 검토

<br>

<br>

<br>

# 7 UML

## 7.1 개념 모델링

+ 개념 모델링 종류 : Use Case Diagram, Data Flow Model, State Model, Goal-Based Model, User Interactions, Object Model, Data Model

## 7.2 UML (Unified Modeling Language)

+ UML : 객체지향 소프트웨어 개발 과정에서 사용하는 범용 모델링 언어, 럼바우(OMT) + Booch(Booch) + Jacobson(OOSE)
+ 럼바우 객체지향 분석 기법
  - 객체 모델링 : 객체 다이어그램
  - 동적 모델링 : 상호작용 등의 상태를 상태 다이어그램
  - 기능 모델링 : 자료 흐름
+ UML 의 특성 : 비주얼화, 문서화, 명세화, 구축
+ UML 소프트웨어에 대한 관점 : 기능적 관점(사용자 측면), 정적 관점(구조적), 동적 관점(내부 동작)
+ UML 의 기본 구성 : 사물, 관계, 다이어그램
+ 스테레오 타입 : 길러멧(<<>>) 확장 요소
+ UML 접근 제어자 : Public(+), Private(-), Protected(#), Package(~)

## 7.3 UML 다이어그램의 분류

+ 구조적 다이어그램 : 클래스 (객체 간의 관계를 추상화, 클래스 이름, 속성, 메소드), 객체, 복합체 구조, 배치, 컴포넌트, 패키지 다이어그램
+ 행위 다이어그램 : 유스케이스, 활동, 상태 머신, 콜라보레이션, 순차 (Sequence), 상호작용, 통신, 타이밍 다이어그램

## 7.4 UML 관계 표현

+ UML 관계 표현 : 단방향, 양방향, 의존(-->), 일반화(-삼각형, 상속), 집합(-마름모), 실체화(--삼각형) 
+ 연관 관계 (Association) : 클래스가 연관 있다면 서로 참조 가능, 사용 후에도 유지됨

+ 의존 관계 (Dependency) : 참조하는 객체나 클래스가 사용 후 사라짐
+ 일반화 관계 (Generalization) : 상속 (차-버스,택시), 일반화된 사물과 특수화된 사물의 관계, is a
+ 집합 관계 (Aggregation) : A 객체가 B 객체에 포함된 관계 (빈 마름모), is part of
+ 포함 관계 (Composition) : 부분이 전체에 속하는 강한 집합 연관의 관계 (찬 마름모)
+ 실체화 관계 (Realization) : 인터페이스와 클래스 간의 관계, 의무적 관계, 한 객체가 다른 객체에 의해 오퍼레이션을 수행하도록 지정

## 7.5 Use Case Diagram

+ Use Case Diagram 의 개념 : 사용자의 요구를 기능적 측면에서 기술
+ 요소 : 시스템 경계(행위), 액터, 유스케이스, 접속 관계, 사용 관계, 확장 관계
  - 연관 : use case 와 actor 의 관계
  - 확장 : 기본 use case 수행 시 특별한 조건을 만족할 때 수행할 use case
  - 포함 : 시스템의 기능이 별도의 기능을 포함

+ 작성 단계 : 액터식별, 유즈케이스식별, 관계 정의, 구조화

<br>

<br>

<br>

# 8 소프트웨어 아키텍쳐

## 8.1 소프트웨어 아키텍쳐

+ 소프트웨어 아키텍쳐 : 구조, 설계도, 요구사항 만족

## 8.2 UI 표준을 위한 환경 분석

+ 사용자 경향 분석 : 연령대, 요구사항, 기능위주
+ 기능 및 설계 분석 : 기능 조작성, 오류방지, 최소한의 조작으로 업무 처리 가능한 형태 분석, UI 정보전달력 확인
+ 요구사항 요소 : 데이터 요구, 기능 요구, 제품서비스 품질, 제약 사항
+ 정황 시나리오 작성 : 서비스의 초기 모양, 육하원칙, 간단명료

<br>

<br>

<br>

# 9 UI 표준 및 지침

## 9.1 UI 표준 및 지침

+ User Interface : 상호작용에 필요한 화상, 문자, 소리, 수단
+ 분야 : 표현, 정보제공, 기능
+ 특징 : 실사용자의 만족도, 아키텍쳐 숙지
+ UI 개발 시스템이 가져야 할 기능 : 입력 검증, 에러 처리, 도움과 프롬프트

## 9.2 UI 설계

+ UI 설계 원칙 : 직관성, 유효성, 학습성, 유연성
+ 설계 지침 : 사용자 중심, 일관성, 단순성, 가시성, 표준화, 접근성, 결과예측가능, 명확성, 오류발생해결

## 9.3 UI 표준

+ UI 구현 표준 : 공통 화면 구성 등
+ 한국형 웹 콘텐츠 접근성 지침 : 인식의 용이성, 운용의 용이성, 이해의 용이성, 견고성

## 9.4 UX

+ User eXperience : 성능, 시간, 감성 공학
+ 모바일 사용자 고려사항 : 직관적, 입력 최소화, 되돌림

<br>

<br>

<br>

# 10 UI 설계

## 10.1 UI 설계 단계

+ UI 설계 단계 : 문제 정의, 사용자 모델 정의, 작업 분석, 오브젝트 기능 정의, UI 정의, 디자인 평가(GOMS, Heuristics)
+ 상세 설계 단계 : UI 메뉴 구조 설계, 내외부 화면과 폼설계, UI 검토수행
+ 시나리오 작성 원칙 : 트리구조나 플로우차트 표기법을 이용한다. 완전성, 일관성, 이해성, 가독성, 수정 용이성, 추적 용이성

## 10.2 UI 설계 도구

+ 와이어프레임 : 레이아웃을 선을 이용해 개략적으로 작성, 핸드라이팅, 파워포인트, 키노트, 스케치, 카카오 오븐
+ 목업(Mockup) : 실물과 흡사한 정적 모형(스마트폰), 발사믹 목업, 파워 목업, 카카오 오븐
+ 프로토타입 : 상호작용이 결합한 실제 작동 모형
+ 스토리보드 : 설계 문서, 개발자-디자이너와의 의사소통을 돕는 도구

## 10.3 UI 프로토타입

+ 프로토타입 : HTML, Axure, 카카오 오븐, Flinto, 네이버 프로토 나우
+ 장단점 : 사용자 중심, 개발 시간 감소, 오류 방지 / 수정이 많아지면 힘들어, 자원 소모, 문서 작업 생략

## 10.4 감성 공학

+ 감성 공학 : 1류(의미 미분법, 감각, 감성) / 2류(+생활 양식) / 3류(특정 시제품)
+ 감성 공학 요소 기술 : 기초 기술, 구현 기술, 응용 기술

<br>

<br>

<br>

# 11 소프트웨어 설계 모델링

## 11.1 소프트웨어의 설계

+ 소프트웨어 설계 모델링 : 무엇을 어떻게 만들것인가
+ 소프트웨어 설계 분류
  - 상위 : 아키텍쳐 설계, 데이터 설계, 인터페이스 정의, 사용자 인터페이스 설계
  - 하위 : 모듈 설계, 자료 구조 설계, 알고리즘 설계
+ 상위 설계 : 예비, 뼈대 / 하위 설계 : 상세
+ 소프트웨어 설계 대상 : 구조 모델링 (컴포넌트, 모듈, 내부 설계 구조), 행위 모델링 (기능 수행, 상호작용, 데이터)
+ 소프트웨어 설계 방법 : 구조적 설계(Coad, Yourdon), 자료 중심 설계(Jackson Warner-Orr), 객체지향 설계(추상화, Rumbaugh, Sheller/Meller)
+ 소프트웨어 구조도
  - Fan-in : 위에서 들어오는 구조, 재사용 측면에서 잘된 설계, 단일 장애 발생 가능성, 중점 관리
  - Fan-out : 아래로 나가는 구조, 단순 설계 해야함

## 11.2 코드 설계의 개요

+ 코드의 기능
  - 기본 기능 : 표준화, 간소화 기능
  - 3대 기능 : 분류, 식별, 배열 기능
  - 부가적 기능 : 연상, 암호화, 오류 검출 기능

## 11.3 코드의 종류

+ 순차 코드 : 일련번호, 항목이 적고 변경이 적은 자료, 누락된 번호 삽입이 어려움
+ 블록 코드 : 각 블록 안에서 일련번호 배정
+ 그룹 분류식 코드 : 대분류, 중분류, 소분류
+ 10진 분류 코드 : 도서 분류 코드
+ 표의 숫자 코드 : 대상 항목의 길이, 넓이, 무게 등을 나타내는 문자나 숫자 (127-890-1245 두께-폭-길이)
+ 연상 코드(기호 코드) : 품목 명칭 일부를 약호 형태로 배정 (TV-39-C TV 39인치 컬러)
+ 오류 종류 : 필사(한자리 잘못), 전위(좌우 바꿈), 이중(전위 2개), 생략, 추가, 임의(두가지 이상)

## 11.4 구조적 개발 방법론

+ 구조적 분석 : 자료의 흐름을 중심으로 전체 시스템의 일관성 있는 이해를 돕는 분석 도구, 체계적, 정형화, 문서화, 자료 사전, 소단위 명세

+ 자료 흐름도(DFD)
  - 버블 차트, 4가지 기본 기호
  - 프로세스 : 시스템의 한 부분, 동그라미
  - 자료 흐름 : 자료의 이동, ->
  - 자료 저장소(Data store) : 파일, 데이터베이스, 위아래 밑줄
  - 단말 : 입력과 출력, 네모
+ 소단위 명세서
  - 최하위 단계 버블의 처리 절차를 기술, 프로세스 명세서
  - 구조적 언어, 의사 결정 나무, 의사 결정표
+ 자료 사전
  - = (정의), + (연결), | (or), * * (주석), () (생략), {}n (n 번이상반복), [] (선택)
  - 자료 항목, 자료 저장소, 자료에 대한 의미, 자료 원소의 단위 및 값

<br>

<br>

<br>

# 12 모듈

## 12.1 모듈과 결합도, 응집도

+ 모듈 : 재사용과 컴파일 가능, 독립성
+ 결합도
  - 서로 다른 두 묘듈간의 상호 의존도, 낮을수록 독립성이 향상되어 유지보수가 쉬워짐
  - 자료 결합도 : 모듈 간 인터페이스가 매개변수나 인수로만 구성, 모듈 간 영향을 주지 않음
  - 스탬프 결합도 : 같은 자료 구조를 조회, 배열, 레코드
  - 제어 결합도 : 제어 신호
  - 외부 결합도 : 외부로 선언한 변수를 참조
  - 공통 결합도 : 여러 모듈이 공통 자료 영역을 사용
  - 내용 결합도 : 내부 기능 및 내부 자료를 참조
+ 응집도
  - 모듈 안의 요소들이 서로 관련된 정도, 높을 수록 필요한 요소들로 구성됨
  - 기능적 : 기능 요소들이 한 문제와 연관
  - 순차적 (Sequential) : 다음 기능 요소의 입력 자료로 제공
  - 교환적 : 같은 입출력 사용
  - 절차적 (Procedural) : 다수의 관련 기능이 순차적 수행
  - 시간적 : 특정 시간에 처리되는 기능
  - 논리적 : 유사, 특정 형태로 분류되는 요소
  - 우연적 (Coincidental) : 관련 없는 요소
+ 모듈 설계의 특징 : 결합도는 낮게, 응집도는 높게

## 12.2 모듈과 컴포넌트

+ 모듈 : 소스코드의 집합, 특정 기능을 완벽히 수행하지 않음
+ 컴포넌트 : 실행코드의 집합, 독립적인 기능을 수행, 인터페이스를 통해 연결

## 12.3 재사용과 공통 모듈

+ 재사용 규모에 따른 구분 : 함수와 객체의 집합이 모듈 / 모듈의 집합을 컴포넌트 / 컴포넌트의 집합을 애플리케이션
+ 공통 모듈 : 서브시스템에서 공통으로 사용하는 모듈
+ 모듈 명세화 도구 : Flowchart, N-S 도표, 의사 코드, 의사 결정표, 의사 결정도, 상태 전이도, PDL, 행위도
+ N-S 도표 : 구조적 프로그램의 순차, 선택, 반복 구조를 사각형, 삼각형으로 도식화

<br>

<br>

<br>

# 13 Software Architecture

## 13.1 소프트웨어 아키텍쳐

+ 소프트웨어 아키텍쳐 : 성능, 사용 운용성, 보안성, 시험 용이성, 가용성, 변경 용이성, 사용성
+ 특징 : 간략성, 추상화, 가시성, 복잡도 관리 종류(추상화)
+ 아키텍처 프레임워크 : 필요한 기본 구조를 제공, 재사용 가능
+ 프레임워크 구성 요소 : 아키텍쳐 디스크립션(AD, 설명서), 이해관계자, 관심사, 관점, 뷰
+ 소프트웨어 아키텍쳐 4 + 1 View Model : BOOch
  - Logical View(분석 및 설계), Implementation View(프로그래머), Process View(시스템 통합자), Deployment View(시스템 엔지니어), Use Case View(사용자)
+ 소프트웨어 아키텍쳐 평가 방법론의 종류 : SAAM, ATAM, CBAM, ARID

<br>

<br>

<br>

# 14 소프트웨어 아키텍쳐 패턴

## 14.1 소프트웨어 아키텍쳐 패턴

+ 종류 : Layered, Client-Server, Master-Slave, Pipe-Filter, Broker
+ 장점 : 유지보수, 관계자 간 의사소통 간편
+ Layered 패턴 : 계층 단위로 분할, N-tier 패턴
+ MVC(Model View Controller) : 핵심기능+정보표시+입력처리
+ 클라-서버 패턴 : 하나의 서버 컴포넌트와 다수의 클라 컴포넌트로 구성
+ 파이프 필터 : 데이터 흐름의 각 단계를 필터 컴포넌트로 캡슐화해 생성하고 처리, 버퍼링 또는 동기화 목적
+ Peer To Peer : 분산 컴퓨팅 구축시 유연성을 제공
+ 브로커 : 컴퓨터와 사용자를 연결
+ 블랙보드 : 음성인식, 신호해석
+ 이벤트 버스 : 이벤트 소스, 이벤트 리스너, 채널, 이벤트 버스 
+ 인터프리터 : 해석 컴포넌트

<br>

<br>

<br>

# 15 객체지향 설계

## 15.1 구조적, 절차적 프로그래밍과 객체지향

+ 구조적 프로그래밍 : 순차-선택-반복
+ 절차적 프로그래밍 : 인터프리터, 순서대로 하나씩 실행, 함수 기반
+ 객체지향 분석 : 속성과 메소드를 객체로 모델링
+ 객체지향 구성 요소
  - Object : 캡슐화, 인스턴스
  - Class : 유사한 객체를 묶은 집합, 타입, 추상화, 상속
+ 객체지향의 특징 : 캡슐화, 정보은닉, 추상화(기능, 제어, 자료), 상속성, 다형성
+ 오버로딩 : 과부하, 한 클래스 내에서 같은 이름의 메소드를 여러개 사용
+ 오버라이딩 : 상속, 덮어쓰기
+ 객체지향 설계 원칙(SOLID)
  - 단일 책임의 원칙 : 모든 클래스는 하나의 책임만 가지고 캡슐화 해야함
  - 개방 폐쇄의 원칙 : 확장에 대해 열려있고 수정에 대해 닫혀있어야 함
  - 리스코프치환 원칙 : 상속된 클래스는 속성 변경 없이 교체 가능해야 함
  - 인터페이스 분리 원칙 : 자신이 사용하지 않는 메소드와 의존관계를 맺지 않아야 함
  - 의존 역전 원칙 : 의존 관계를 맺을 때 변화하기 쉬운 것보다 어려운 것에 의존해야 함

## 15.2 객체지향 개발 방법론

+ 객체지향 개발 방법론
  - Rumbaugh : OMT (객체 모델링)
  - Booch : OOD, 미시적 거시적 개발 프로세스를 모두 사용
  - Jacobson : Object Oriented SW Engineering, Use Case
  - Coad-Yourdon : E-R 다이어그램
  - Wirfs-Brock : 고객 명세서를 평가해 설계까지 연속적으로 수행

## 15.3 클래스 설계

+ 클래스 설계 : 객체의 상태 변화 모델링
+ 클래스 협약에 의한 설계 : 선행조건, 결과조건, 불변조건

<br>

<br>

<br>

# 16 디자인 패턴

## 16.1 디자인 패턴

+ 장점 : 의사소통, 시간 단축, 생산성 높음 / 초기 투자 비용
+ 구성 요소 : 패턴의 이름, 문제 및 배경, 해법, 결과 / 추가 요소 : 알려진 사례, 샘플 코드, 원리, 정당성, 근거
+ GoF(Gangs of Four) : 에릭 감마, 리처드 헬름, 랄프 존슨, 존 브리시데스

  - 생성 패턴
    - Factory Method(생성자 함수)
    - Singleton(전역 변수 X)
    - Prototype(인스턴스 복제)
    - Builder(조립)
    - Abstraction Factory(추상 팩토리)
  - 구조 패턴
    - Adapter(재사용)
    - Bridge(각자 독립적으로 변형)
  - 행위 패턴 : 상호작용, 책임 분배 방법을 정의
    - 책임 연쇄
    - 반복
    - 명령 (Command)
    - 해석자
    - 기록
    - 감시자 (Observer)
    - 상태 (State)
    - 전략
    - 방문자 (Visitor)
    - 중재자 (Mediator, 통제)

<br>

<br>

<br>

# 17 인터페이스 요구사항 확인

## 17.1 인터페이스 요구사항

+ 인터페이스 요구사항 : 상호작용을 위한 접속 방법, 규칙 등 (네이버아이디로그인 서비스 추가)
+ 검증 방법
  - 프로포타이핑 : 시제품
  - 테스트 설계 : Test Case
  - CASE : Computer Aid Software Engineering, 일관석 분석
  - 검토 : 동료 검토 / 워크스루(명세서-짧은검토회의) / 인스펙션(다른 전문가)

<br>

<br>

<br>

# 18 인터페이스 대상 식별

## 18.1 대상 식별

+ 인터페이스 데이터 표준 : 공통부, 개별부, 종료부

+ 직접 연계 방식 : 솔루션 없이 / 간접 연계 방식 : 연계 솔루션
+ 인터페이스 연계 기술 : DB Link(객체), DB Connection(WAS), API, JDBC(JAVA), Hyper Link(웹), Socket(포트 할당, 클라이언트), Web Service(WSDL, UDDI, SOAP 프로토콜), 연계 솔루션(EAI)

## 18.2 연계 기술

+ API : 카카오페이 결제, 네이버 로그인 등
+ WSDL(Web Services Description Language) : 웹 서비스
+ UDDI(Universal Description, Discovery, and Integration) : XML 기반의 레지스트리
+ SOAP(Simple Object Access Protocol) : 객체 간의 통신 규약

<br>

<br>

<br>

# 19 미들웨어 솔루션

## 19.1 미들웨어

+ 클라와 서버 간의 통신을 담당하는 시스템 소프트웨어
+ 종류 : 데이터베이스, TP-Monitor(ATM에서 입금 후 통장에 찍히기까지 사이클), ORB(브로커), RPC(원격프로시저), MOM(메세지 기반), WAS(동적 웹, HTTP), 객체 트랜잭션 모니터(TP-monitor+ORB)

<br>

<br>

<br>

# 20 통합 구현

## 20.1 단위 모듈 구현

+ 단위 모듈 : 한가지 동작을 수행하는 모듈
+ 원리 : 분할과 지배 / 정보 은폐 / 자료 추상화 / 모듈의 독립성

+ 코딩 계획 - 코딩 - 컴파일 - 테스트

## 20.2 통합 개발 환경

+ IDE : 이클립스, 비주얼 스튜디오, 안스튜
+ 빌드 자동화 도구 : 실행 도구
  - 컴파일 - 패키징 - 단위 테스트 - 정적 분석 - 리포팅 - 배포 - 최종 빌드
  - 종류 : Gradle(JVM, 안드로이드), Jenkins(오픈소스), Makefile, Ant, Maven(종속성)

<br>

<br>

<br>

# 21 제품 소프트웨어 패키징

## 21.1 애플리케이션 패키징

+ 배포용 설치 파일을 만드는 작업
+ 패키징 도구 : 불법 복제 방지, 라이선스 관리, 권한 제어
+ 구성 요소 : 암호화 / 키 관리 / 암호화 파일 생성 / 식별 기술 / 저작권 표현 / 정책 관리 / 크랙 방지 / 인증

## 21.2 모니터링 도구와 협업 도구

+ APM : 애플리케이션 변경, 성능 관리
+ 협업 도구 : 이해관계자 간의 의견 공유

<br>

<br>

<br>

# 22 제품 소프트웨어 저작권

## 22.1 제품 소프트웨어 저작권 보호

+ DRM(Digital Rights Management) : 암호화 및 키관리, 콘텐츠 식별체계 표현, 라이선스 관리
+ 유통 과정과 구성 : 콘텐츠 제공 - 분배 - 소비
  - 콘텐츠 제공자 / 분배자 / 패키저 / 보안 컨테이너 / DRM Controller / Clearing House (정산 분배)
+ 사용 권한 : 렌더 퍼미션 (문서 인쇄 권한 제어) / 트랜스포트 퍼미션 (복사, 이동) / 데리버티브 퍼미션 (추출, 임베드, 에디트)

<br>

<br>

<br>

# 23 제품 소프트웨어 매뉴얼 작성

## 23.1 소프트웨어 매뉴얼

+ 설치 매뉴얼 기본 사항 : 개요, 파일, 아이콘, 프로그램 삭제, 추가 정보
+ 기능 식별 - UI 분류 - 설치/백업 파일 확인 - 언인스톨 - 이상 case 확인 - 최종 매뉴얼

## 23.2 소프트웨어 사용자 매뉴얼

+ 작성 지침 정의 - 구성 요소 정의 - 구성 요소별 내용 작성 - 사용자 매뉴얼 검토
+ 소프트웨어 국제 표준 품질 특성 : ISO/IEC 9126 (품질 특성) / ISO/IEC 12119 (테스트) / ISO/IEC 1550

## 23.3 Release Note 작성하기

+ 배포 정보 문서, 버전 관리

<br>

<br>

<br>

# 24 형상 관리

## 24.1 형상 관리 도구

+ Configuration Management : 작업물 추적, 통제
+ 형상 관리 항목 : 요구 분석서, 설치 지침서, 요구사항 명세서, 인터페이스 명세서, 테스트 설계서, 소프트웨어 품질보증, 형상 관리, V&V(확인및검증) 계획서, 코드 모듈
+ 형상 관리 종류 : 버전 관리 / 변경 관리(요구사항 변경)
+ 형상 관리 절차 : 형상 식별 / 형상 통제(형상통제위원회, 베이스라인) / 형상 보고 및 감사 / 형상 기록 및 보고
+ 형상 관리 > 버전 관리 > 변경 관리

## 24.2 버전 관리 도구

+ 공유 폴더 방식 : SCCS, RCS (수정을 한 사람이), PVCS
+ 클라이언트 / 서버 방식 : CVS (동시 버전 시스템 / 오픈소스), SVN(Subversion)
+ 분산 저장소 방식 : Git
+ Subversion : import(저장소) / check-out(인출) /  check-in(갱신) / commit(예치) / diff(변경사항) / fork(복사)

<br>

<br>

<br>

# 25 애플리케이션 테스트 관리

## 25.1 테스트 케이스

+ 소프트웨어 테스트 : 품질 향상 관점 / 오류 발견 관점 / 오류 예방 관점
+ 파레토의 법칙 (Law of Pareto) : 80대 20법칙, 전체 결과의 80%가 전체 원인의 20%에서 일어나는 현상 (vip 20% 가 매출 80%)

+ Brooks의 법칙 : 지연되는 프로젝트에 인력을 투입하면 더 늦어진다.

+ 살충제 패러독스 (Pesticide Paradox) : 동일 테스트 케이스로 동일 테스트 반복시 더이상 결함이 발견되지 않는 현상
+ 오류 - 부재의 궤변 : 결함을 모두 제거해도 사용자 요구사항을 만족시키지 못하면 품질이 높다고 할 수 없다.
+ 테스트 커버리지 : 구문 / 결정 / 조건 / 조건결정 / 변경조건결정 / 다중조건

+ 테스트 오라클 : true(모든 입력값) / 일관성(입력출력) / 샘플링 / Heuristic(나머지는 추정)

## 25.2 V모델과 테스트

+ 정적 테스트(검증) : 요구사항분석 - 기능명세분석 - 설계 - 개발
+ 동적 테스트(확인) : 단위 (모듈, 클래스 테스팅) - 통합 - 시스템 - 인수

+ 인수 테스트 : 알파 / 베타 테스트

## 25.3 애플리케이션 테스트

+ 정적 테스트 : 명세서나 소스코드
+ 동적 테스트 : 블랙박스 (Boundary Value Testing, Cause-Effect Graphing) / 화이트박스 (Basis Path Testing, Branch)
+ 구조 기반 테스트 (구문, 결정, 데이터 흐름) / 명세 기반 테스트 (동등 분할, 경계값 분석) / 경험 기반 테스트 (체크리스트)
+ 목적에 따른 테스트 : 성능 / 회복 / 구조 / 회귀 / 안전 / 강도 / 병행
+ 화이트박스 : 코드의 논리적 모든 경로를 오픈, 문장 / 분기 / 조건 / 분기조건
  - 기초 경로 검사 : 제어 흐름
  - 제어 구조 검사
    - 조건검사
    - 루프검사
    - 데이터흐름검사
+ 블랙박스 : 프로그램의 구조를 고려하지 않고 입력과 출력만
  - 동치 분할 검사 : 입력 자료에 초점을 맞춰 케이스를 만들고 검사
  - 원인-효과 그래프 검사 : 입출력영향
  - 오류 예측 검사 : 경험
  - 비교 검사 : 여러 버전
  - 경계값 분석
+ 테스트 시나리오 : 테스트 케이스의 집합

<br>

<br>

<br>

# 26 테스트 커버리지

## 26.1 테스트 커버리지

+ 테스트 범위
+ 기능 / 라인 / 코드 / 구조 / 조건 / 결정

## 26.2 테스트 자동화

+ 도구 : 정적 분석 도구 (코딩) / 테스트 실행 도구 (데이터주도 / 키워드주도) / 성능 테스트 (처리량 응답시간)
+ 테스트 하네스 도구
  - 테스트 드라이버 : 상향식 테스트
  - 테스트 스텁 : 하향식 테스트
  - 테스트 슈트 (응용 분야) / 테스트 케이스 / 테스트 스크립트(명령어) / 목 오브젝트 (미리 입력)

<br>

<br>

<br>

# 28 통합 테스트

## 28.1 통합 테스트

+ 통합 방식 : 비점진적 / 점진적

+ 상향식 / 하향식 / 빅뱅

<br>

<br>

<br>

# 29 결함 관리

## 29.1 결함 관리

+ 결함 관리 도구 : Mantis / Trac / Bugzilla
+ 에러 (개발자의 실수) / 오류 (Fault, 연산자) / 실패 (프로그램) / 결함 (전체적)
+ 결함 내성 : 고장 허용성

<br>

<br>

<br>

# 30 애플리케이션 성능 개선

## 30.1 애플리케이션 성능개선

+ 성능 측정 지표 : 처리량 / 응답시간 / 경과시간 / 자원사용률
+ 성능 저하 원인 : DB Lock / 불필요한 DB Fetch / 연결 누수

## 30.2 알고리즘

+ 문제 해결 방법
+ 설계 기법
  - 분할 정복법 : 과제 분할, 퀵 정렬, 병합 정렬 알고리즘
  - 동적 계획법 : 쉬운 문제부터, 플로이드 알고리즘, 피보나치 수열 알고리즘
  - 탐욕법 : 크루스칼, 다익스트라
  - 퇴각 검색법 : N-Queen
  - 분기 한정법 : 최적 우선 탐색 알고리즘
  - 근사 해법 : NP-Hard, 근사 알고리즘

+ 시간 복잡도 : 연산, 소요시간 계산
  - Big-0 표기법 : O(Nlog2n) 퀵정렬, 병합정렬
  - 0(1) : 상수형 복잡도, 해시 함수, 비례하지 않는, 항상 일정한
  - 0(n) : 선형 복잡도, 정비례하는, 순차 탐색

## 30.3 Mccabe 순환 복잡도

+ 복잡도 : 화살표 수 - 노드 수 + 2 V(G) = E - N + 2
+ 해싱 함수 : 인덱스
  - 제산 방법(Division) : 나머지 연산자
  - 중간 제곱 방법(Mid-Square) : 키값을 제곱
  - 중첩 방법(폴딩) : 나누기, XOR(배타적 논리합)
  - 기수 변환 방법 : 분포
  - 동의어 : 충돌이 일어난 레코드

<br>

<br>

<br>

# 31 소스 코드 최적화

## 31.1 소스 코드 최적화

+ 소스 코드 품질 분석 도구 
  - 정적 분석 도구 : 소스코드검증, 코드리뷰, 리버스엔지니어링
    - pmd : 소스 코드에 대한 미사용 변수, 최적화 안된 코드 등 결함을 유발할 수 있는 코드를 검사
    - cppcheck : C/C++ 코드에 대한 메모리 누수 및 오버플로우 분석
    - SonarQube : 중복 코드나 복잡도 높은 코딩 설계 등을 분석하는 소스 분석 통합 플랫폼
    - ccm : 다양한 언어의 코드 복잡도를 분석
    - checkstyle : 자바 코드에 대해 소스코드 표준을 따르고 있는지 검사
    - cobertura : 자바 코드의 복잡도 분석 및 테스트 커버리지 측정
  - 동적 분석 도구 : 디버깅, 스트레스테스트, 모의해킹
    - Avalanche : valrind 프레임워크 및 stp 기반, 프로그램 결함 및 취약점 분석
    - valgrind : 프로그램 내에 존재하는 메모리 및 쓰레드 결함 분석
    - valMeter

<br>

<br>

<br>

# 32 인터페이스 구현

## 32.1 인터페이스 기능 확인

+ 인터페이스 설계서(정의서)

+ EAI(Enterprise Application Integration) : 기업 내 애플리케이션 간의 정보 전달
  - Point to point : 미들웨어가 없음
  - hub & spoke : 허브
  - message bus : 대용량 데이터 처리
  - hybrid : bus에 허브를 혼합
+ ESB(Enterprise Service Bus) : EAI 확장 개념, 애플리케이션 간의 데이터 변환 및 연계 지원 제공
+ 데이터 표준 확인 : JSON, DB, XML

## 32.2 인터페이스 구현

+ AJAX : 자바스크립트 기반 비동기 통신 기술
+ JSON : 속성 값의 쌍

## 32.3 인터페이스 구현 검증

+ 검증 도구
  - Watir : Ruby 사용
  - xUnit : Java, C++ 등 다양한 언어를 지원하는 단위 테스트 프레임워크
  - FitNesse : 웹 기반 테스트
  - STAF : 서비스 호출 및 컴포넌트 재사용 등 환경을 지원함, 데몬
  - NTAF : 협업 기능과 재사용 및 확장성을 통합한 네이버의 테스트 자동화 프레임워크
  - Selenium : 다양한 브라우저 및 개발 언어를 지원

<br>

<br>

<br>

# 33 인터페이스 보안

## 33.1 인터페이스 보안

+ 데이터 탈취 위협 : 스니핑(패킷훔침) / 스푸핑(흉내사이트)
+ 시큐어 코딩 : OWASP (The Open Web Application Security Project, 10개의 취약점)
+ 전송 계층 보안 : 신뢰성 있는 데이터 전송 (IPSec)
+ 응용 계층 보안 : SSL (https)
+ AH : 메시지 체크섬, 비연결형 무결성 보장

## 33.2 데이터베이스 보안

+ 대칭키 알고리즘 / 해시 알고리즘 / 비대칭키 알고리즘
+ 암호화 기법 : API, Filter, Hybrid

<br>

<br>

<br>

# 34 자료 구조

## 34.1 자료 구조

+ 인덱스 : 데이터베이스 성능에 많은 영향을 주는 DBMS 의 구성요소, 자료를 빠르게 조회하기 위해 별도로 구성한 순서 데이터

## 34.2 선형 자료 구조

+ 리스트
  - 선형 리스트 : 배열, 추가 삭제가 어려움
  - 연결 리스트 : 노드의 추가 삭제가 용이, 메모리 많이 사용, 데이터-링크 형태
+ 스택
  - LIFO(후입선출), Bottom 과 Top, 스택 가드 (오버플로우 상태로 가정해 프로그램 중단)
  - 응용 분야 : 인터럽트 처리, 수식 계산, 재귀 호출, 0-주소 인스트럭션, 깊이 우선 탐색
  - 오버플로우 : 공간이 가득찼을 때 더 넣으려고 하는 경우
  - 언더플로우 : 데이터가 없을 때 꺼내려는 경우
+ 큐 (Queue)
  - 삽입은 선형의 한쪽 끝에서, 제거는 다른쪽 끝에서 수행, FIFO(선입선출)
  - 응용 분야 : 운영체제의 작업 스케줄링
+ 데크 (Deque)
  - 삽입 삭제가 양쪽 끝에서 이루어짐, 스택+큐, 입력 제한 데크 (Scroll), 출력 제한 데크 (Shelf)

## 34.3 비선형 구조

+ 트리
  - 그래프의 특수한 형태, 노드와 가지
  - 관련 용어 : 근노드 (가장 상위 노드), 레벨 (노드의 층), 조상 노드 (근노드까지의 모든 노드), 차수 (자식 노드의 수), 단말 노드 (가장 마지막 노드)
  - 이진 트리 : 차수가 2 이하인 노드로만 구성, 레벨이 5인 트리의 최대 노드 수는 2^5 - 1 = 31개
  - 이진 트리의 구조 : 정이진 트리 (모두 2개씩), 전이진 트리(한쪽 방향 노드 없음), 사향 이진 트리 (한쪽 방향으로만 기울어진 트리)
  - 이진 트리의 운행법 : 전위 (Root-Left-Right), 중위 (Left-Root-Right), 후위 (Left-Right-Root)
  - 연산자 표기 방식 : (AXB) + (CXD) -> + XABXCD (전위 표기) -> ABXCDX + (후의 표기)
+ 그래프
  - 정점과 간선의 집합, 인접 행렬, n(n-1)/2
  - 신장 트리 (Spanning Tree) : 사이클을 이루지 않도록 정점을 연결한 그래프

## 34.4 정렬

+ 삽입 정렬 : 두 번째 값을 키값으로 지정 후 비교 -> 세번째 값을 키값으로 지정 후 비교 ---
+ 버블 정렬 : 두 개씩 정렬, 1회전 마다 제일 큰 값이 뒤로
+ 선택 정렬 : O(n^2), 시간이 오래 걸림, 1회전 마다 제일 작은 값이 앞으로
+ 병합 정렬 : O(nlog_2n), 두 개의 키를 한 쌍으로
+ 퀵 정렬 : O(nlog_2n), 최악 : O(n^2), 부분 교환 정렬법, 하나의 파일을 부분적으로 나눠가며 정렬
+ 힙 정렬 (Heap) : O(nlog_2n), 최악 : O(nlog_2n), 전이진 트리

## 34.5 검색

+ 이분 검색(이진 검색) : 순차 정렬 필수, 효율성 높음 
+ 선형 검색(순차 검색) : 비효율적, (n+1)/2
+ 피보나치 검색, 블록 검색, 이진 트리 검색

## 34.6 해싱

+ 해싱 : 해싱 함수를 이용해 해시 테이블 내의 홈 주소를 계산해 레코드에 접근하는 방식, 직접 접근 파일, 오버플로 위험, 메모리 많이 사용
+ 종류 : 제산 방법, 중간 제곱 방법, 중첩 방법, 기수 변환 방법, 계수(digit) 분석 방법
+ 슬롯 : 한 개의 레코드를 저장할 수 있는 공간, n개의 슬롯이 모여 하나의 버킷을 형성
+ 동의어 : 동일한 홈주소로 인해 충돌이 일어난 레코드
+ 충돌 : 2개의 다른 레코드가 같은 버킷으로 해싱, 오버플로우 발생

## 34.7 인덱스

+ 인덱스 구성 방식 : B 트리, B+ 트리 (현재 사용)
+ 파일 편성 방법 : 색인 순차 파일 (ISAM), 동적 인덱스 색인 순차 파일 (VSAM)
+ 색인 순차 파일의 구성 : 기본 구성, 색인 영역 (트랙, 실린더, 마스터 인덱스), 오버플로 영역 (실린더 오버플로, 독립 오버플로)
+ VSAM 은 기본 영역과 오버플로 영역을 구분하지 않음
+ 직접 파일 : 해싱 함수를 계산해 물리적 주소에 직접 접근하는 방식
+ 역 파일 : 특정 파일을 여러 개의 색인으로 만들고 항목별 특성에 맞게 작업하도록 구성한 구조

+ 정적 인덱싱 : ISAM, 구조는 정적으로 변하지 않음
+ 동적 인덱싱 : VSAM

<br>

<br>

<br>

# 39 데이터베이스

## 39.1 자료 처리

+ Data 와 Information
+ 자료 처리 시스템의 종류 : 일괄 처리, 온라인 처리, 분산 처리
+ 데이터베이스의 정의 : 통합, 저장, 운영, 공용
+ 데이터베이스의 특성 : 실시간 접근성, 내용에 의한 참조 (주소나 위치 아님), 동시 공유, 계속적 변화
+ DBMS 의 필수 기능 : 정의, 조작, 제어 (무결성, 권한)
+ 데이터웨어하우스 : OLAP(On-Line Analytical Processing), Roll-up, Drill-down, Dicing, Slicing)
+ 용어 : 데이터 마이닝, Hadoop (분산처리를 소규모 컴퓨터 다수로)

## 39.2 데이터베이스의 구성

+ 스키마 : 데이터베이스의 구조 (개체, 속성, 관계) 에 대한 정의
+ 스키마 3계층 : 외부 스키마 (접근 정의), 개념 스키마 (데이터 접근 권한, 무결성 규칙), 내부 스키마 (실제 저장 방법)
+ 데이터베이스 언어 : 정의, 조작, 제어
+ 데이터베이스 사용자 : 관리자 (DBA), 응용 프로그래머, 일반 사용자

## 39.3 데이터베이스 모델

+ 데이터 모델 : 데이터베이스 설계 과정에서 데이터의 구조를 표현하기 위한 도구
+ 구성 요소 : 데이터 구조, 연산, 제약조건
+ 개념적 모델 : E-R 다이어그램 (개체-사각형, 관계-마름모, 속성-타원, 연결-실선)
+ 논리적 모델 : 계층형 (트리구조), 네트워크(망)형 (그래프 구조), 관계형 (table의 집합), 객체지향형

## 39.4 관계형 데이터베이스 모델

+ 모델 구조 : 릴레이션 구조 - 학생 / 속성 - 학번, 이름, 학과, 디그리 (속성의 수) / 튜플 - 레코드, 카디널리티 (튜플의 수) / 도메인 - 하나의 속성이 가질 수 있는 값의 영역
+ 릴레이션의 특징 : 튜플의 유일성, 튜플의 무순서성, 속성의 원자성, 속성의 무순서성
+ Key 의 종류와 무결성
  - 슈퍼키 : 두 개 이상의 속성으로 구성된 키 또는 혼합키 (학번+나이, 주민번호+이름)
  - 후보키 (기본키가 될 수 있는 후보들, 유일성과 최소성 만족), 기본키 (후보키들 중에서 선택), 대체키 (남은 후보키)
  - 외래키 : 다른 테이블의 기본키로 사용되는 속성 (학생 테이블의 학번은 참조키, 수강 테이블의 학번은 외래키)
  - 개체 무결성 : 기본키의 값은 null 이나 중복 값을 가질수 없음
  - 참조 무결성 : 외래키를 변경하려면 참조키도 변경해야함
  - 도메인 무결성 : 릴레이션 중 하나의 속성은 반드시 원자값이어야함

## 39.5 데이터베이스 설계

+ 설계 단계 
  - 요구조건 분석
  - 개념적 설계
  - 논리적 설계 (데이터 모델링)
    - 개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계
    - 스키마의 평가 및 정제
    - 개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 매핑 및 모델화
    - 트랜잭션 인터페이스 설계
  - 물리적 설계 (데이터 구조화)
    - 논리적 구조로 표현된 데이터를 물리적 구조의 데이터로 변환
    - 데이터베이스 파일의 저장 구조 및 엑세스 경로 설정
    - 저장 레코드의 양식 설계, 레코드 집중의 분석 및 설계, 접근 경로 설계
    - 성능에 중대한 영향을 미침

## 39.6 데이터베이스 정규화

+ 데이터베이스 정규화 : 구조의 안정화, 중복 최소화, 수정 삭제시 이상 현상 최소화
+ 함수적 종속 : 결정자 (학번), 종속자 (이름), 학번 -> 이름
  - 완전 함수적 종속, 이행 함수적 종속 (x->y, y->z, x->z)
+ 1정규형 : 릴레이션의 도메인은 원자값만으로 구성
+ 2정규형 : 부분 함수적 종속 제거, 두 개의 테이블로 분할
+ 3정규형 : 이행적 함수 종속 제거, 두 개의 테이블로 분할
+ BCNF (보이스/코드) 정규형 : 결정자가 후보키가 아닌 함수 종속을 제거
+ 4정규형 : 다치 종속 제거
+ 5정규형 : 후보키를 통하지 않은 조인 종속 제거
+ 도부이결다조!

## 39.7 데이터베이스 반정규화

+ 정규화를 통해 테이블 개수가 증가함에 따라 조회 성능이 떨어질 수 있음 -> 운영의 단순화
+ 반정규화를 위해서는 사전에 데이터의 일관성과 무결성을 우선으로 할지, 데이터베이스의 성능과 단순화를 우선으로 할지를 결정해야 함
+ 기법 : 테이블 반정규화, 컬럼 반정규화, 관계 반정규화
+ 테이블 반정규화 기법
  - 테이블 병합 : 1:1, 1:다, 슈퍼:서브
  - 테이블 분할
    - 파티셔닝, 분산기법, 분할키 기준 분할
    - 범위, 해시, 조합 (Composite), 목록, 라운드-로빈
  - 테이블 추가
    - 집계 테이블 추가 : sum, avg 등의 계산 미리 수행
    - 중복 테이블 추가 : 다른 업무거나 서버가 다른 경우 동일한 테이블 구조를 중복해 원격조인을 제거하고 성능을 향상
    - 이력 테이블 추가 : 레코드 중복 저장
    - 부분 테이블 추가 : 접근 시도가 많은 자료만 모아두기
    - 진행 테이블 추가 : A에 접근하기 위해 다수의 테이블을 거칠 경우 간소화
+ 컬럼 반정규화 기법 : 중복 컬럼 추가, 파생, 이력 테이블, PK(Primary Key)
+ 관계 반정규화 기법 : 중복 관계 추가, 데이터 무결성을 깨뜨리지 않고도 성능 향상이 가능함
+ 클러스터링 : 두 대 이상의 서버를 하나의 서버처럼 운영 (병렬처리, 고가용성 클러스터링)

<br>

<br>

<br>

# 40 관계 대수와 연산자

## 40.1 관계 대수와 관계 해석

+ 관계 대수 : 절차적 언어, 연산의 집합
+ 순수 관계 연산자
  - Select(합) : 튜플 집합 검색, 수평적 연산
    - 시그마학과='전자과'(학생) : 학생 릴레이션에서 학과가 전자과인 학생의 튜플을 반환
  - Project(파이) : 속성 집합 검색, 수직적 연산
  - Join(리본) : 두 릴레이션의 공통 속성을 연결해 새로운 릴레이션을 반환
  - Division(나누기 기호) : R÷S는 S에 포함된 튜플을 모두 가지는 R의 튜플 중에, S에 포함된 애트리뷰트를 제거하고 반환
+ 집합 연산자 : 합집합, 교집합, 차집합, 교차곱 (Cartesian Product, 속성은 더하고 튜플은 곱하고)

<br>

<br>

<br>

# 41 SQL (Structured Query Language)

## 41.1 SQL

+ 관계형 데이터베이스의 표준 질의어

+ DDL : CREATE (스키마, 도메인, 테이블, 뷰 정의), ALTER (필드 추가, 삭제, 갱신), DROP (Cascade, Restrict)

+ DML : SELECT (DISTINCT 중복 생략), INSERT INTO VALUES, DELETE FROM WHERE, UPDATE SET WHERE
  - having - group by, 구간값 계산 AND
  
+ DCL

  - 데이터 보안, 무결성 유지, 병행 제어, 회복을 위한 제어용 언어
  - COMMIT, ROLLBACK, GRANT (권한 부여), REVOKE (권한 취소)

+ 뷰 (View)

  - 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된 이름을 가지는 가상 테이블

  - 저장장치 내에 논리적으로 존재
  - 데이터의 논리적 독립성 제공
  - 뷰의 정의 변경 시 ALTER 로 변경할 수 없고, DROP 문을 사용해야함

+ 시스템 카탈로그 : 데이터 사전, 메타 데이터, DBMS 가 스스로 생성하고 유지

+ 트리거 (Trigger) : 데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL

+ NoSQL (Not only SQL)

+ in (1, 2, 3) = (1 or 2 or 3)

<br>

<br>

<br>

# 42 트랜젝션, 병행 제어

## 42.1 트랜잭션

+ 정의 : 데이터베이스에서 일어나는 연산의 집합, 작업 단위
+ 특성
  - 원자성 (Atomicity) : 트랜잭션의 연산은 모두 실행되거나 모두 실행되지 않아야 함 (Commit / Rollback)
  - 일관성 (Consistency) : 고정 요소는 트랜잭션 수행 전과 후가 같아야 함
  - 격리성 (Isolation) : 병행 실행되는 경우 하나의 트랜잭션 실행 중에 다른 연산이 끼어들수 없음
  - 영속성 (Durability) : 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함
+ CRUD Matrix : 데이터베이스 분석 툴
+ 트랜잭션 연산 : COMMIT, ROLLBACK, RECOVERY

## 42.2 병행 제어

+ 동시에 수행되는 트랜젝션들을 일관성 있게 처리하기 위해 제어 (동시 접속)

+ 종류 : 로킹 (LOCKING), 최적 병행 수행, 타임스탬프 (트랜잭션간의 순서), 다중 버전 기법
  - 로킹 : 단계별 로킹, 2단계 로킹 (확장, 축소)
    
    - 병행 제어를 위해 트랜잭션이 접근하고자 하는 데이터를 잠가 다른 트랜잭션이 접근하지 못하도록 하는 병행 제어 기법
    - 로킹 단위 : 필드, 레코드, 테이블, 파일, 데이터베이스 전체
    
    - 로킹 단위 크면 : 병행수준, 데이터베이스 공유도, 오버헤드 저하, 제어기법 간단해 관리 수월
    - 로킹 단위 작으면 : 병행수준, 데이터베이스 공유도, 오버헤드 증가, 제어기법 까다러워 관리 복잡

<br>

<br>

<br>

# 43 보안, 분산 데이터베이스

## 43.1 보안

+ 암호화
  - 비밀키(대칭키) : 암호화=복호화
  - 공개키(비대칭키) : 암호화!=복호화
+ 권한 부여 기법 : GRANT (권한 부여) / REVOKE (권한 취소)

## 43.2 분산 데이터베이스

+ 목표 : 위치 투명성, 중복 투명성, 병행 투명성, 장애 투명성
+ 장/단점 : 시간 단축, 공유성 신뢰성 가용성 향상 / 비용 증가, 오류 발생 증가, 통신망 성능에 좌우

<br>

<br>

<br>

# 44 C언어

## 44.1 C언어의 기초

+ 1972 벨 연구소의 데니스 리치에 의해 개발
+ 컴파일러 방식, 포인터에 의한 번지 연산
+ 기본 자료형
  - 정수형 : short (2byte), int (4byte) , long (4byte) 가변적임
  - 실수형 : float (4byte), double (8byte)
  - 문자형 : char (1byte)
+ 기억 클래스 : 자동 변수, 레지스터 변수, 정적 변수, 외부 변수
+ 입출력 함수 - 표준 입출력 함수
  - scanf() : 표준 입력 함수
  - printf() : 표준 출력 함수
  - getchar() : 문자 입력 함수
  - putchar() : 문자 출력 함수
  - gets() : 문자열 입력 함수, string
  - puts() : 문자열 출력 함수
+ 입출력 함수 - 변환 문자 (출력 형식 지정 문자)
  - %d : 10진 정수, decimal
  - %o : 8진 정수, octet
  - %x : 16진 정수, hexa
  - %f : 실수형, %e : 지수형, %c : 문자, %s : 문자열
+ 문자열 처리 함수
  - strcat(n1, n2) : 문자열 연결 함수
  - strrev() : 거꾸로 변환
+ 이스케이프 시퀀스 : ＼n (다음 줄), ＼r (carriage return), ＼t (tab), ＼b (뒤로 한칸), ＼f (한페이지)
+ 변수명 작성 규칙 : 영문 대소문자 + 숫자 + _ 혼용 가능, 첫 글자는 영문자나 _로 시작, 대소문자 구분, 공백 X
+ 포인터 변수 : 주소값 저장, 메모리 크기 동일, *연산자
+ 표준 라이브러리 함수 : stdio.h
  - 함수 종류 : atoi (문자->정수), atol (문자->log), itoa (숫자->문자), ceil, floor, rand, div

## 44.2 C언어 연산자

+ 단항 연산자 : ! (부정), ~ (1의 보수), & (변수의 주소), * (변수의 내용), sizeof (Byte 단위로 크기를 구함)

+ 산술 연산자

+ 시프트 연산자 : <<, >> (a=1, a<<1 이면 00000001에서 이동 00000010)

+ 비트 연산자 : 논리곱, 논리합, 배타적논리합(^)

+ 삼항 연산자 : 조건식 ? 참일때 : 거짓일때

+ 연산자 우선 순위  : 단항 산술 비트 관계 논리 비트논리 조건 할당

+ 0이 아닌 모든 값은 1, A=65

+ ```c
  int arr[2][3]={1,2,3,4,5,6}
  int (*p)[3]=NULL;
  p=arr;
  printf("%d ", *(p[0]+1) + *(p[1]+2));
  printf("%d", *(*(p+1)+0) + *(*(p+1)+1));
  
  // [0] 1, 2, 3 [1] 4, 5, 6
  // arr[0]번에 인덱스[1] = 2
  // arr[1]번에 인덱스[2] = 6
  // 2 + 6 = 8
  
  int n = 4;
  int* pt = NULL;
  pt=&n; // pt는 변수 n의 주소값
  // &n = 변수 n의 주소값
  // *pt = pt가 가리키는 주소에 저장된 값 = 변수 n
  // *&pt = *(pt의 주소값) = 변수 n의 주소값
  
  static int b[9]={1,2,3};
  // b[5]의 값은 0
  // static = 초기화
  ```

<br>

<br>

<br>

# 45 Java 언어

## 45.1 Java 언어의 기초

+ 객체지향 언어
+ 추상화, 상속화, 다형성
+ Carbage Collector : 불필요한 메모리 정리
+ 기본 자료형
  - 정수형 : byte (1byte), short (2byte), int (4byte), long (8byte)
  - 실수형 : float (4byte), double (8byte)
  - 문자형 : char (2byte)
  - 논리형 : boolean (1byte)
+ 접근 제어자 : public, private (상속 관계 객체), default, protected (현재 객체 내)
+ 출력 함수
  - System.out.print() : 괄호 안을 출력하고 줄바꿈 안함
  - System.out.printin() : 출력 후 줄바꿈
  - System.out.printf() : 변환 문자를 사용해 출력
+ 변환 문자 (출력 형식 지정 문자) : C언어와 동일
+ 변수명 작성 규칙 : C언어와 동일 + $ 사용
+ 오버로딩 : 한 클래스 내에서 같은 메소드 이름 사용
+ 오버라이딩 : 상속 관계의 상위 클래스에서 정의한 메소드를 하위 클래스에서 재정의

<br>

<br>

<br>

# 46 제어문

## 46.1 조건문

+ if 문 : if...else 문 / if...else if...else 문 / 삼항 연산자
+ switch...case 문

## 46.2 반복문

+ while
+ do...while
+ for

<br>

<br>

<br>

# 47 스크립트 언어와 Python

## 47.1 스크립트 언어

+ 스크립트 언어 : 소스 코드를 컴파일 과정을 거치지 않고 실행할 수 있는 언어, 인터프리터 언어
+ 서버 : ASP (윈도우), JSP, PHP (리눅스, 유닉스), 파이썬
+ 클라이언트 : Javascript, VBScript

## 47.2 파이썬

+ 1991년 귀도 반 로섬이 개발
+ 인터프리터식, 객체지향적, 동적 타이핑, 쉬움
+ 변수명 작성 규칙 : 영문 대소문자 + 숫자 + _  사용 가능, C언어와 동일
+ python 조건문 if, elif, else
+ 데이터 타입
  - 시퀀스 : 리스트 (순서 있고 가변), 튜플 (순서 있고 불변)
  - 세트 : 순서 없고 중복X
  - 맵 : 딕셔너리 (순서 없고 키-밸류)
+ print() : 자동으로 개행
+ 문자열 출력

```python
string = 'Python Good' // 공백 포함

s = string[1]
print(s) // y

s = string[-1]
print(s) // d

s = string[:] // 모두 출력
print(s) // Python Good

s = string[7:] // x번째 인덱스부터
print(s) // Good

s = string[:3] // y-1번째 인덱스까지
print(s) // Pyt

s = string[1:3]
print(s) // yt

s = string[1:8:2]
print(s) // yhnG
```

+ 메서드의 첫 번째 매개변수 self를 명시적으로 구현하는 것은 파이썬만의 독특한 특징

```python
def setdata(self, first, second):
	self.first = first
	self.second = second
>>> a = FourCal()
>>> a.setdata(4, 2)
>>> a.setdata(a, 4, 2)
```

<br>

<br>

<br>

# 48 운영체제와 프로세스

## 48.1 운영체제

+ 운영체제 : 사용자와 하드웨어 간의 인터페이스로서 동작
+ 운영 방식 : 일괄 처리, 다중 프로그래밍, 시분할 시스템, 다중 처리, 실시간
+ 제어 프로그램 : 감시, 작업 제어, 데이터 관리
+ 처리 프로그램 : 언어 번역, 서비스, 문제 프로그램

## 48.2 프로세스 관리

+ 프로세스 : 실행 중인 프로그램
+ PCB (Process Control Block) : 운영체제가 프로세스를 관리하기 위해 정보를 저장해 놓은 곳
+ 스레드
  - 프로세스 내의 작업 단위, 한 개의 프로세스는 여러 개의 스레드를 가짐
  - 장점 : 하드웨어 운영체제 성능과 처리율 향상, 응용프로그램 응답시간 단축, 실행 환경을 공유해 메모리 낭비 감소
  - 커널 스레드 : 운영체제 커널에 의해 운용, 구현 쉽고 속도 느림
  - 사용자 스레드 : 사용자가 만든 라이브러리를 사용해 스레드 운용, 구현 어렵고 속도 빠름
+ 프로세스 상태의 종류 : new, ready, running, exit, block, deadlock, terminated, submit, hold, pending
+ 병행 프로세스 : 임계 영역 (충돌 방지), 상호배제 (다른 프로세스 배제), 동기화 기법 (다익스트라, 세마포어, 수신호, 모니터)
+ 교착상태 (Deadlock)
  - 점유 및 대기 (Hold and wait)
  - 상호배제 (Mutual exclusion)
  - 비선점 (Non-preemption)
  - 환형 대기 (Circular wait)
+ 교착상태 해결 방법
  - 예방
  - 회피 (Avoidance) : 은행가 알고리즘
  - 발견 (Detection) : 자원 할당 그래프
  - 회복 (Recovery) : 자원 선점, 프로세스 종료

## 48.3 프로세스 스케줄링

+ 비선점 : 다른 프로세스가 끝날때까지 기다리는 방식

  - FCFS(FIFO) : 선입선출
    - 실행 순서 : 1 - 2 - 3
    - 대기 시간 : 1 (0), 2 (10), 3 (40)
    - 반환 시간 : 1 (13), 2 (45), 3 (50)

  | 작업 | 도착 시간 | 실행 시간 |
  | :--: | :-------: | :-------: |
  |  P1  |     0     |    13     |
  |  P2  |     3     |    35     |
  |  P3  |     8     |    10     |

  - SJF (Shortest Job First) : 실행 시간이 가장 짧은 프로세스
    - 실행 순서 : 2 - 1 - 4 - 3
    - 대기 시간 : 2 (0), 1 (3), 4 (9), 3 (16)
    - 반환 시간 : 2 (3), 1 (9), 4 (16), 3 (24)

  | 작업 | 실행 시간 |
  | :--: | :-------: |
  |  P1  |     6     |
  |  P2  |     3     |
  |  P3  |     8     |
  |  P4  |     7     |

  - HRN (Highest Response-ratio Next) : 실행 시간과 기다린 시간으로 우선순위 결정, SJF 보안
    - 계산식 : (대기 시간 + 서비스를 받을 시간) / 서비스를 받을 시간

  | 작업 | 대기 시간 | 서비스 실행 시간 |
  | :--: | :-------: | :--------------: |
  |  P1  |     5     |        20        |
  |  P2  |    40     |        20        |
  |  P3  |    15     |        45        |
  |  P4  |    20     |        20        |

  - 우선 순위 : 우선 순위가 가장 높은 프로세스, 무한 정지 가능성을 에이징으로 해결

+ 선점 : 우선 순위가 높은 다른 프로세스가 빼앗을 수 있음, 타이머 클럭

  - RR (Round Robin) : 주어진 시간 할당량 안에 작업을 마치지 않으면 뒤로 배치
  - SRT (Shortest Remaining Time) : 실행시간 추정치가 가장 작은 작업
  - 다단계큐 : 단계별 준비 상태 큐
  - 다단계 피드백큐 

## 48.4 기억 장치 관리

+ 반입 전략 : 보조 기억 장치의 데이터를 주기억 장치로 언제 가져올 것인지 결정하는 전략
+ 배치 전략 : 보조 기억 장치의 데이터를 주기억 장치 내의 어디로 가져올 것인지 결정하는 전략
  - 최초 적합, 최상 적합, 최악 적합
+ 교체 전략
  - OPT (가장 이상적)
  - FIFO
  - LRU (Least Recently Used) : 최근에 가장 적게 쓴
  - LFU (Least Frequently Used) : 최근에 가장 적게 참조된
  - NUR (Not Used Recently) : 최근에 사용 안한
  - SCR (Second Chance Replacement) : FIFO 단점을 보완
+ 가상 기억 장치 구현 기법 : 주기억 장치의 부족한 용량을 해결하기 위해 보조 기억 장치를 주기억 장치처럼 사용
  - 페이징 기법 : 맵테이블, 동일한 크기로 나눔
    - 페이지 크기가 작은 경우 : 기억장소 이용 효율적, 입출력 시간 증가
  - 세그멘테이션 기법 : 다양한 크기로 나눔
+ 구역성 : 시간 구역성, 공간 구역성
+ 워킹 셋 : 자주 참조하는 페이지들의 집합
+ 스레싱 : 프로세스 수행보다 이동에 소요되는 시간이 더 커지는 현상
+ 페이지 부재 : 참조할 페이지가 주기억 장치에 없는 현상
  - 페이지 참조 순서 : 1,2,3,1,2,4,1,2,5
  - 프레임 : 3개
  - 교체 알고리즘 : FIFO
  - 페이지 결함 : 7번

## 48.5 디스크 스케줄링

+ 디스크의 여러 곳에 저장된 데이터를 액세스 하기 위해 헤드의 이동 경로를 결정하는 기법
+ 종류 : FCFS, SSTF (Shortest Seek Time First), SCAN (왕복), C-SCAN (밖->안), 에센바흐 (한 회전 동안 처리)

## 48.6 정보 관리

+ 파일 시스템 : 연관된 데이터들의 집합
+ 파일 디스크립터 (File Descriptor) : 파일 제어 블록, 파일의 생성 시간, 수정 시간

## 48.7 분산 운영체제

+ 다중 처리기 : 하나의 시스템에 두 개 이상의 프로세서를 가지고 여러 개의 작업을 처리하는 장치
+ 상호 연결 방법 
  - 하이퍼 큐브 : 10개 이상의 프로세서를 병렬로 동작, n개의 프로세서 = 2^n
  - 시분할 공유 버스, 크로스바 교환 행렬, 다중 포트 메모리
+ 다중 처리기 운영체제의 구조 : 주종처리기, 분리수행, 대칭적
+ 약결합 / 강결합

## 48.8 UNIX

+ 특징 : 시분할, 개방형, 트리구조, 멀티유저, C언어
+ 구성
  - 커널 (Kernel) : 프로세스, 메모리, 입출력 관리를 수행, 컴퓨터 부팅시 주기억 장치에 적재된 후 상주
  - 쉘 (Shell) : 시스템과 사용자 간의 인터페이스, 명령어 해석기, 주기억 장치에 상주하지 않고 파일 형태로 존재하며 보조 기억 장치에서 교체 처리가 가능
  - 유틸리티
+ 구조 : 부트 블록, 슈퍼 블록, I-node 블록 (파일 디스크립터), 데이터 블록
+ 파일 관련 명령어 : cat (파일의 내용을 메모장처럼 화면에 표시), chmod (사용 권한 지정), chown (소유자 변경), fork (새로운 프로세스 생성)
+ 로그 파일 명령어
  - wtmp : 사용자 로그인 로그아웃 정보 (last 명령어로 확인 가능)
  - lastlog : 사용자별 마지막 로그인 시간 등 정보 저장
  - message : 시스템 사용에 관한 모든 로그
+ 환경 변수 : 쉘이 값을 전달해주는 역할, 컴퓨터에 프로세스가 동작하는 방식에 영향을 미침, 대문자
+ BASH Shell : LINUX 표준 쉘
+ 파일 생성 권한 : 666

## 48.9 OSI 7계층

+ Open Systems Interconnection : 프로토콜을 기능별로 나눈 것
+ 응표세전네데물!
+ 물리 계층 : 프로토콜 (X.21, RS-232C, V.24)
+ 데이터 링크 계층 : 동기화 오류제어 흐름제어, 인접한 두개의 통신 시스템, 프로토콜 (HDLC, PPP, LLC, LAPB, LAPD, ADCCP)
+ 네트워크 계층 : 경로 설정, IP패킷 (X.25, ICMP, IGMP)
+ 전송 계층 : 신뢰할 수 있는 통신, (TCP, UDP)
+ 세션 계층 (통신 방식), 표현 계층 (암호화 등 데이터 변환)
+ 응용 계층 : HTTP, POP3, SMTP, DNS, FTP, Telnet

## 48.10 오류 제어 방식

+ 자동 반복 요청
  - Stop-and-Wait ARQ : 송신 확인 - 수신 응답, ACK - NAK
  - 연속 ARQ : 일단 다보내고 오류 생기면 거기서부터 다시 보냄 / 선택적 : 오류 발생 블록만
  - 적응적 ARQ : 채널의 상태에 따라 동적으로 변경

## 48.11 TCP/IP 프로토콜

+ 인터넷 기본 프로토콜

+ 응용 계층 - 전송 계층 - 인터넷 계층 - 링크 계층

+ TCP : 전송 계층, 흐름 제어, 전이중 방식, 패킷의 전송 및 오류 제어, 신뢰성 (UDP)

+ IP : 네트워크 계층, 비신뢰성
  - ICMP (Internet Control Message Protocol) : 오류 보고와 수정 보완, 에코 메세지
  - IGMP (Internet Group Management Protocol) : 멀티캐스트
  - ARP (Address Resolution Protocol) : IP 주소를 이용해 MAC 주소를 찾음, 
  - RARP (Reverse ARP) : MAC 주소로 IP 주소를 찾음, 
  
+ IP 주소
  - IPv4 : 32비트
  - IPv6 : 128비트, 인증 보안 기능, 확장 헤더, 유니캐스트, 애니캐스트, 멀티캐스트
  - 주소 체계 : 클래스 A (0~127), 클래스 B (128~191), 클래스 C (192~223)
  - 듀얼 스택 / 터널링 / 헤더 변환
  
+ 서브넷 마스크 : 203.241.132.82/27 -> 호스트 ID 5개 -> 11100000 -> 255.255.255.224

+ IEEE 802 : 이더넷, 무선 통신 기술에 대한 물리적, 데이트 링크 계층 사양을 다루는 네트워크 표준 집합
  - 802.4 : 토큰 버스
  - 802.5 : 토큰 링
  - 802.8 : 고속 이더넷
  - 802.11 :무선 랜 (a : 5GHz / e : MAC)
  - 802.15 : 블루투스
  
+ CSMA/CA : 무선 / 충돌 회피

+ CSMA/CD : 유선 / 신호가 흐르는지, 데이터가 흐르는지, 충돌이 발생하는지 

+ 논리 주소와 물리 주소

  - 논리주소 = (세그먼트번호, 변위값)
  - 물리주소 = 세그먼트 시작주소 + 변위값

  - 예제 : 논리주소 (2, 176) 일때 물리주소는 시작주소 + 변위값

<br>

<br>

<br>

# 49 소프트웨어 개발 방법론 활용

## 49.1 소프트웨어 개발 생명주기 모형

+ 프로토타입 모형, 폭포수 모형, 나선형 모형
+ CPM (Critical Path Method) : 노드와 간선 / 가장 긴 기간을 찾아서 계산
+ 구조적 방법론 : 흐름 다이어그램, 구조도
+ 객체지향 방법론
+ 컴포넌트 기반 개발 방법론 (CBD)
  - 산출물 (분석, 설계, 구현, 시험)
  - 특징 : 반복 점진적 개발 프로세스, 유스케이스 다이어그램
+ 소프트웨어 재사용 : 합성 (부품, 블록), 생성 (추상화 형태의 명세를 구체화)

## 49.2 비용 산정 모델

+ 전문가 감정 기법 : 2인 이상의 전문가에게 의뢰
+ 델파이 기법 : 전문가의 견해를 조정자가 조정해 결정
+ LOC (Line of code) : 낙관치 + (4 * 기대치) + 비관치 / 6
+ COCOMO (COnstructive COst MOdel) : Boehm, Basic, Intermediate, Detailed
  - 소프트웨어 개발 유형 : Organic Mode (단순형, 0~5만 라인 이하) / Semi-detached Mode (중간형, 5만~30만 라인 이하, 운영체제, 데이터베이스) / Embedded Mode (30만 라인 이상, 초대형 트랜잭션)
+ Putnam : Rayleigh-Norden 곡선의 노력 분포도 / SLIM
+ 기능 점수 (Functional Point) : 능력별 가중치 (자료 입력, 정보 출력, 명령어, 데이터 파일)

## 49.3 소프트웨어 개발 표준

+ ISO/IEC 9126 : 소프트웨어 품질 특성과 평가를 위한 국제 표준
  - 내외부 품질 : 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성
  - 사용 품질 : 효과성, 생산성, 안정성, 만족도
  - 외부 지표, 내부 지표
+ ISO/IEC 25010 : 위에꺼에서 2개 추가
+ ISO/IEC 12119 : 테스트
+ ISO/IEC 12207 : 체계적인 프레임워크 (획득, 공급, 개발, 운영, 유지보수)
+ SPICE (Software Process Improvement and Capability dEtermination) : 품질 및 생산성의 국제 표준 (ISO/IEC 15504)
  - 불완전 - 수행 - 관리 - 확립 - 예측 - 최적
+ CMM (Capability Maturity Model) : 소프트웨어 개발 프로세스 조직의 성숙도 수준
  - 초기 - 관리 - 정의 - 정량적 관리 - 최적
+ CMMI (Integration) : 소프트웨어, 시스템, 프로덕트를 포함

## 49.4 테일러링과 프레임워크

+ 테일러링 : 기존 개발 방법론을 상황에 맞게 수정하는 작업
  - 내부적 요건 : 목표환경, 요구사항, 프로젝트 규모, 보유 기술
  - 외부적 요건 : 법적 제약사항, 표준 품질 기준
+ 프레임워크 : 재사용이 가능한 아키텍쳐와 협력하는 소프트웨어 산출물의 집합
+ 스프링 (자바, 동적 개발) / 닷넷 (마이크로소프트)

<br>

<br>

<br>

# 50 네트워크 구성

## 50.1 네트워크 구성

+ 성형 : 중앙 호스트를 중심으로 터미널이 연결되는 중앙 집중식
+ 링형, 버스형, 트리형
+ 망형 : 회선수 계산 공식 n(n-1)/2

## 50.2 네트워크 장비

+ 허브 : 공유기
+ 브릿지 : 데이터 링크 계층, 근거리 통신 (MAC 연결)
+ 스위치 : 두 개 이상의 LAN 연결, 보안 및 트래픽 관리
  - L4 스위치 : 로드밸런싱, 4계층
+ 라우터 : 경로 설정
+ 게이트웨이 : 네트워크 식별
+ 리피터 : 신호 증폭, 장거리 전송
+ VLAN : 물리적 배치와 상관없는 논리적 구성

## 50.1 네트워크 관련 신기술

+ RIP (Routing Information Protocol) : 홉 (거리값 15), 최단 거리 탐색, 거리 벡터 라우팅
+ OSPF (Open Shortest Path First Protocol) : 링크 상태 라우팅 알고리즘, 개방형, IGP (내부 게이트웨이)
+ MQTT (Message Queuing Telemetry Transport) : 사물 인터넷, 경량 메시지 전송 프로토콜
+ USN : 무선 센싱 네트워크
+ 클라우드 컴퓨팅 : IaaS, Paas, SaaS / PaaS-TA (개방형 클라우드 컴퓨팅 플랫폼)
+ 그리드 컴퓨팅 : 하둡
+ PICONET : 여러 개의 독립된 통신 장치가 통신망을 형성
+ 스마트 그리드 : 전력망에 정보 기술을 접목, 에너지 효율 극대화
+ Wi-sun : 스마트 그리드와 같은 장거리 무선 통신을 필요로 하는 IOT 서비스를 위한 저전력 장거리 통신 기술
+ WPAN (Wireless Personal Area Network) : 무선 사설망
+ 비컨 : 최대 70m 이내의 장치들과 교신
+ 포스퀘어 : GPS 기반 소셜 네트워크 서비스
+ ZigBee : 낮은 전력을 소모하는 네트워크
+ Mesh Network : 기존 무선 랜의 한계 극복
+ WDM (Wavelength Division Multiplexing) : 레이저, 광신호, 광섬유를 다중화
+ NDN : 콘텐츠 자체의 정보와 라우터 기능만으로 데이터 전송을 수행
+ NGN : 유선망 기반의 차세대 통신망
+ RFID, NFC

<br>

<br>

<br>

# 51 소프트웨어/하드웨어 신기술

## 51.1 소프트웨어

+ 소프트웨어 정의 데이터 센터 (SDDC) : 가상 데이터 센터, 추상화, 풀링, 자동화 등을 통해 가상화
+ 텐서플로우 (Tensorflow) : 구글 개발, 인공지능 응용 프로그램 개발용 프레임워크
+ 머신 러닝/딥 러닝 : 패턴 찾기, 자율 주행 자동차
+ 디지털 트윈 : 사물과 동일하게 표현되는 모델, 메타버스
+ HMD : 버추얼 장비
+ 블록체인 : 공공 거래 장부, 분산 원장 기술
+ BaaS (Backend as a Service) : 블록체인 개발 환경을 클라우드로 서비스
+ Mashup : 구글의 하우징맵스 (지도 + 부동산 매물 정보)
+ 양자 암호 : 양자 암호키 분배 (QKD)
+ SOA (Service Oriented Architecture) : 대규모 컴퓨터 시스템을 구축할때, 업무상 소프트웨어의 기능을 서비스로 판단해 그 서비스를 네트워크 상에 연동하여 전체를 구축하는 방법론
  - 계층 : 표현, 프로세스, 서비스, 비즈니스, 영속 계층

## 51.2 하드웨어

+ 4D 프린팅 : 온도, 습도에 반응
+ N-Screen : 동일 컨텐츠를 여러 기기에서 자유롭게

<br>

<br>

<br>

# 52 데이터베이스 관련 기술 용어

+ RAID : 하드디스크를 여러개 연결해 용량 확장, 신뢰성 보장
+ 웨어러블 컴퓨팅
+ 멤리스터 : 메모리 + 레지스터, m.2
+ DAS (Direct Attached Storage) : 직접 연결 저장 장치, 호스트 어댑터에 직접 연결
+ NAS : 네트워크 데이터 저장 장치
+ SAN (Storage Area Network) : 다른 운영체제를 가진 여러 기종이 네트워크 상에서 동일 저장 장치를 공유
+ SDS (Software Defined Storage) : 가상화 서버
+ 데이터 웨어 하우스 / 데이터 마트
+ Hadoop : 소형 컴퓨터 연결, 자바 기반
  - Sqoop : 하둡과 관계형 DB 간에 데이터를 전송할수 있는 도구
  - 맵리듀스 : 대용량 데이터를 분산처리 하기 위한 프로그래밍 모델, 병렬 처리 기법, 임의의 순서

<br>

<br>

<br>

# 53 소프트웨어 개발 보안

## 53.1 소프트웨어 개발 보안

+ Secure OS : 커널에 보안 기능을 추가
+ 버퍼 오버플로 : 스택 실드, ASLR, 스택 가드 (특정 값을 저장했다가 변경될 경우 오버플로우로 실행 중단)
+ 시스로그 : Linux 로그 파일

## 53.2 소프트웨어 개발 보안 방법론

+ Secure SDLC (System Development Life Cycle)

+ MS-SDL : MS사에서 개발
+ Seven Touchpoints : SW 보안의 모범 사례를 통합, 각 단계의 7개 체크리스트
+ CLASP (Comprehensive, Lightweight Application Security Process) : 초기 단계의 보안 강화
+ 정보 보안의 3대 요소
  - 기밀성 : 인가된 사용자만 접근 / 방화벽, 암호 / 신분 위장
  - 무결성 : 데이터 접근 / 변경, 가장, 재전송
  - 가용성 : 필요한 사용자가 접근할 수 있는 능력 / 데이터 백업 / 서비스 거부 (DDOS)
+ OWASP (The Open Web Application Security Project) : 10개의 취약점

## 53.3 시큐어 코딩 가이드

+ 입력 데이터 검증
  - SQL Injection : 검증되지 않은 외부 입력값이 쿼리문에 삽입되어 공격 / 컴파일된 SQL 쿼리문을 전달
  - 크로스 사이트 스크립트 (XSS) : 게시판 원본글에 악성코드 실행 / 문자열 치환 함수나 라이브러리 사용
  - 경로 조작 및 자원 삽입 : 시스템 자원에 삽입
  - XQuery : 동적 쿼리 생성 시
  - XPath 삽입 : 검증되지 않은 경로
  - LDAP (Lightweight Directory Access Protocol) 삽입 : 네트워크 상의 자원을 식별하고 인가된 사용자만 접근하도록 하는 네트워크 디렉토리 서비스
+ 보안 기능
  - 중요 정보 평문 저장
  - 하드 코드된 비밀번호 : 관리자의 정보 노출
+ 시간 및 상태
  - 경쟁 조건 : 검사 시점과 사용 시점 (TOCTOU) : 여러 프로세스 접근 시 한번에 하나만 접근하게 방지
  - 종료되지 않는 반복문 또는 재귀함수
+ 에러 처리
  - 에러 메시지를 통한 정보 노출
  - 에러 상황 대응 부재
  - 부적절한 예외 처리
+ 코드 오류
+ 캡슐화 : 제거되지 않고 남은 디버그 코드, 시스템 데이터 정보 노출
+ API 오용

## 53.4 암호화 알고리즘

+ 암호 알고리즘 : 암호화 / 복호화
+ 공개키 (비대칭키) : 암호화 != 복호화, 2N
  - RSA : 소인수 분해
  - ElGama : 이산대수
+ 비밀키 (대칭키) : 암호화 == 복호화, 속도 빠름, 키교환 필요, N(N-1)/2
  - 스트림 : 평문의 길이와 동일한 스트림, XOR, RC4
  - 블록 : DES, AES, ARIA, SEED, IDEA
+ 해시 : 단방향, 주어진 원문에서 고정된 길이의 의사난수를 생성, 디지털 서명에 이용, 블록체인 (MD4, MD5, SHA-1)
+ Salt : 같은 패스워드들이 다른 암호 값으로 저장되도록 추가되는 값

## 53.5 서비스 공격 유형

+ Dos : 가용성을 위협
  - 스머프 : 대량의 ICMP 패킷을 전송, 브로드캐스트
  - SYN 플러딩 : 3-way 핸드셰이킹
  - Ping 플러딩 : ICMP Echo
  - UDP 플러딩
  - 티어드랍 : 패킷 조각을 조작
  - Ping of Death : Ping을 이용해 패킷을 정상보다 크게해서 쪼개지게 함
  - LAND : 포트나 IP 주소를 임의 변경해 출발지 = 목적지
+ DDos : 여러 대의 공격자를 분산 배치, Trinoo, TFN, Stacheldraht (슈탛ㅎ드랗ㅎ독일어^^;)
+ 피싱 : 가짜 웹 사이트
+ 이블 트윈 공격 : 피싱의 무선 버전
+ 파밍 : 도메인 탈취, DNS 이름을 속임
+ 랜섬웨어
+ 키 로거 : 키보드 정보
+ 무작위 대입 공격 : 비밀번호 난수
+ APT (Advanced Persistent Threat) : 지능적 지속 위협, 조직을 타깃
+ 제로데이 공격 : 해당 취약점에 대한 패치가 나오지 않은 시점에서 이루어지는 공격
+ TCP 세션 하이재킹
  - 세션을 탈취하고 인증을 회피
  - 탐지 방법 : 비동기화 상태 감지, ACK STORM 탐지, 리셋 탐지, 인증 수준 높은 프로토콜 사용
+ 백도어
  - 공격 도구 : NetBus, Back Orifice, RootKit
  - 탐지 방법 : 무결성 검사, 열린 포트 확인, 로그 분석, SetUID 파일 검사
  - tripwire : 크래커가 백도어를 만들거나 파일을 변경했을 때 분석하는 도구
+ 블루투스 공격
  - 블루버그 : 장비사이의 취약한 연결 관리를 악용
  - 블루스나프 : OPP (인증없이 간편 교환) 를 사용해 장비의 파일에 접근
  - 블루프린팅 : 공격 장치의 검색 활동
  - 블루재킹 : 스팸처럼 명함을 익명으로 퍼뜨리는 것
+ switch jamming : 스위치가 더미 허브처럼 작동하게 됨
+ IPSec : 네트워크 계층에서 IP 패킷 단위의 데이터 변조 방지 및 은닉 기능을 제공하는 프로토콜
+ SSL (Secure Sockets Layer) : 전송 계층과 응용 계층 사이에서 인증, 암호화, 무결성을 보장하는 프로토콜
+ S-http : 클라이언트와 서버 간에 전송되는 모든 메시지를 암호화 하는 프로토콜

## 53.6 서버 인증 및 서버 접근 통제

+ 서버 인증 : 지식 기반 인증, 소유 기반 인증 (OTP), 생체 기반 인증

+ 서버 접근 통제

  - 강제적 접근 통제 : 중앙에서 정책적으로 접근 제어, 벨라파듈라
  - 임의적 접근 통제 : 정보 소유자가 결정, 
  - 역할 기반 접근 통제 : 직책에 따른 권한 부여

  |   정책    | MAC (Mandatory Access Control) | DAC (Discretionary) | RBAC (Role-Based) |
  | :-------: | :----------------------------: | :-----------------: | :---------------: |
  | 권한 부여 |             시스템             |    데이터 소유자    |    중앙 관리자    |
  | 접근 결정 |       보안 등급 (Label)        |   신분 (Identity)   |    역할 (Role)    |
  | 정책 변경 |      고정적, 변경 어려움       |      변경 용이      |     변경 용이     |
  |   장점    |      안정적, 중앙 집중적       |  구현 용이, 유연함  |     관리 용이     |

+ 접근 통제 요소 : 식별 - 인증 - 인가

+ 접근 통제 모델

  - 벨라파듈라 모델 : 군사 보안 레벨, 기밀성에 따라 상하 관계
  - SSO (Single Sign-On) : 통합 로그인 솔루션

+ 보안 아키텍쳐 : 보안 시스템의 모든 양상에 대한 세부 사항

+ 보안 프레임워크 : 정보 보안 시스템의 기본이 되는 뼈대

## 53.7 보안 솔루션과 보안 아키텍쳐

+ IDS (Instrusion Detection System): 침입 탐지 시스템
  - HIDS 호스트 기반 : 시스템 내부를 감시하고 분석
  - NIDS 네트워크 기반 : 네트워크 상의 모든 패킷

  - 침입 탐지 기법 : 오용 탐지 (이미 알려진 공격 패턴) / 이상 탐지 (통계적)

+ IPS : 침입 방지 시스템, 즉각 대응 가능

+ 방화벽 : 내부-외부 네트워크 사이에 위치
  - 기본 구성 요소 : 배스천 호스트, 스크리닝 라우터
  - 이중 홈 게이트웨이
  - 듀얼 홈드 호스트 : 외부망과 내부망 포트가 분리
  - 단일 홈 게이트웨이
  - 스크린된 서브넷 게이트웨이 : DMZ 구간을 두어 네트워크를 분리

+ DMZ : 보안 조치가 취해진 네트워크 영역, 웹 DNS 메일 서버, 내부 방화벽과 외부 방화벽 사이

+ IPSec : 네트워크 계층 보호, 전송모드 / 터널모드

  - ESP (Encapsulating Security Payload) : AH + 기밀성 보장, 전체를 보호
  - AH (인증 헤더) : 인증과 무결성에 대해서만 검사, 해시함수와 대칭키

+ DLP : 기업 데이터 유출을 방지하는 보안 솔루션

+ ESM : 통합 보안 관리

+ VPN : 가상 사설망



