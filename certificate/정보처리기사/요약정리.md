### 소프트웨어 개발 방법론

+ 소프트웨어의 개념 : 프로그램, 자료구조, 문서
+ 재공학의 과정
  - 분석 : 재공학 대상을 선정
  - 구성(구조변경) : 기존 소프트웨어의 향상을 위해 코드를 재구성
  - 역공학 : 기존 소프트웨어를 분석해 소스코드를 얻어내는 작업
  - 이식 : 다른 운영체제나 하드웨어에서 사용할 수 있도록 변환하는 작업
+ CASE 원천 기술 : 구조적 기법, 프로토타이핑 기술, 정보 저장소 기술
+ 자료 흐름도 : 프로세스, 자료 흐름, 자료 저장소, 단말
+ 자료 사전 : = (정의), + (연결), | (or), * * (주석), () (생략), {}n (n 번이상반복), [] (선택)



### UML

+ UML 의 기본 구성 : 사물, 관계, 다이어그램

+ 구조적 다이어그램 : 클래스 (객체 간의 관계를 추상화, 클래스 이름, 속성, 메소드), 객체, 복합체 구조, 배치, 컴포넌트, 패키지 다이어그램
+ 행위 다이어그램 : 유스케이스, 활동, 상태 머신, 콜라보레이션, 순차 (Sequence), 상호작용, 통신, 타이밍 다이어그램
+ 연관 관계 (Association) : 클래스가 연관 있다면 서로 참조 가능, 사용 후에도 유지됨
+ 의존 관계 (Dependency) : 참조하는 객체나 클래스가 사용 후 사라짐
+ 일반화 관계 (Generalization) : 상속 (차-버스,택시), 일반화된 사물과 특수화된 사물의 관계, is a
+ 집합 관계 (Aggregation) : A 객체가 B 객체에 포함된 관계 (빈 마름모), is part of
+ 포함 관계 (Composition) : 부분이 전체에 속하는 강한 집합 연관의 관계 (찬 마름모)
+ 실체화 관계 (Realization) : 인터페이스와 클래스 간의 관계, 의무적 관계, 한 객체가 다른 객체에 의해 오퍼레이션을 수행하도록 지정



### 모듈

+ 결합도
  - 서로 다른 두 묘듈간의 상호 의존도, 낮을수록 독립성이 향상되어 유지보수가 쉬워짐
  - 자료 결합도 : 모듈 간 인터페이스가 매개변수나 인수로만 구성, 모듈 간 영향을 주지 않음
  - 스탬프 결합도 : 같은 자료 구조를 조회, 배열, 레코드
  - 제어 결합도 : 제어 신호
  - 외부 결합도 : 외부로 선언한 변수를 참조
  - 공통 결합도 : 여러 모듈이 공통 자료 영역을 사용
  - 내용 결합도 : 내부 기능 및 내부 자료를 참조
+ 응집도
  - 모듈 안의 요소들이 서로 관련된 정도, 높을 수록 필요한 요소들로 구성됨
  - 기능적 : 기능 요소들이 한 문제와 연관
  - 순차적 (Sequential) : 다음 기능 요소의 입력 자료로 제공
  - 교환적 : 같은 입출력 사용
  - 절차적 (Procedural) : 다수의 관련 기능이 순차적 수행
  - 시간적 : 특정 시간에 처리되는 기능
  - 논리적 : 유사, 특정 형태로 분류되는 요소
  - 우연적 (Coincidental) : 관련 없는 요소



### 소프트웨어 아키텍쳐

+ 소프트웨어 아키텍쳐 4 + 1 View Model : BOOch
  - Logical View(분석 및 설계)
  - Implementation View(프로그래머)
  - Process View(시스템 통합자)
  - Deployment View(시스템 엔지니어)
  - Use Case View(사용자)
+ 평가 방법론의 종류 : SAAM, ATAM, CBAM, ARID

+ 소프트웨어 아키텍쳐 패턴
  - Layered 패턴 : 계층 단위로 분할, N-tier 패턴
  - MVC(Model View Controller) : 핵심기능+정보표시+입력처리
  - 클라-서버 패턴 : 하나의 서버 컴포넌트와 다수의 클라 컴포넌트로 구성
  - 파이프 필터 : 데이터 흐름의 각 단계를 필터 컴포넌트로 캡슐화해 생성하고 처리, 버퍼링 또는 동기화 목적
  - Peer To Peer : 분산 컴퓨팅 구축시 유연성을 제공
  - 브로커 : 컴퓨터와 사용자를 연결
  - 블랙보드 : 음성인식, 신호해석
  - 이벤트 버스 : 이벤트 소스, 이벤트 리스너, 채널, 이벤트 버스 
  - 인터프리터 : 해석 컴포넌트
+ 디자인 패턴
  - 생성 패턴
    - Factory Method(생성자 함수)
    - Singleton(전역 변수 X)
    - Prototype(인스턴스 복제)
    - Builder(조립)
    - Abstraction Factory(추상 팩토리)
  - 구조 패턴
    - Adapter(재사용)
    - Bridge(각자 독립적으로 변형)
  - 행위 패턴 : 상호작용, 책임 분배 방법을 정의
    - 책임 연쇄
    - 반복
    - 명령 (Command)
    - 해석자
    - 기록
    - 감시자 (Observer)
    - 상태 (State)
    - 전략
    - 방문자 (Visitor)
    - 중재자 (Mediator, 통제)



### 객체지향 설계

+ 객체지향 설계 원칙(SOLID)
  - 단일 책임의 원칙 : 모든 클래스는 하나의 책임만 가지고 캡슐화 해야함
  - 개방 폐쇄의 원칙 : 확장에 대해 열려있고 수정에 대해 닫혀있어야 함
  - 리스코프치환 원칙 : 상속된 클래스는 속성 변경 없이 교체 가능해야 함
  - 인터페이스 분리 원칙 : 자신이 사용하지 않는 메소드와 의존관계를 맺지 않아야 함
  - 의존 역전 원칙 : 의존 관계를 맺을 때 변화하기 쉬운 것보다 어려운 것에 의존해야 함

+ 객체지향 개발 방법론
  - Rumbaugh : OMT (객체 모델링)
  - Booch : OOD, 미시적 거시적 개발 프로세스를 모두 사용
  - Jacobson : Object Oriented SW Engineering, Use Case
  - Coad-Yourdon : E-R 다이어그램
  - Wirfs-Brock : 고객 명세서를 평가해 설계까지 연속적으로 수행



### 미들웨어

+ 종류
  - 데이터베이스
  - TP-Monitor(ATM에서 입금 후 통장에 찍히기까지 사이클)
  - ORB(브로커)
  - RPC(원격프로시저)
  - MOM(메세지 기반, 느리고 안정적)
  - WAS(동적 웹, HTTP)
  - 객체 트랜잭션 모니터(TP-monitor+ORB)



### 통합 구현

+ 빌드 자동화 도구 : 실행 도구
  - 컴파일 - 패키징 - 단위 테스트 - 정적 분석 - 리포팅 - 배포 - 최종 빌드
  - 종류 : Gradle(JVM, 안드로이드), Jenkins(오픈소스), Makefile, Ant, Maven(종속성)



### 형상 관리

+ 공유 폴더 방식 : SCCS, RCS (수정을 한 사람이), PVCS
+ 클라이언트 / 서버 방식 : CVS (동시 버전 시스템 / 오픈소스), SVN(Subversion)
+ 분산 저장소 방식 : Git
+ Subversion : import(저장소) / check-out(인출) /  check-in(갱신) / commit(예치) / diff(변경사항) / fork(복사)



### 테스트 케이스

+ 파레토의 법칙 (Law of Pareto) : 80대 20법칙, 전체 결과의 80%가 전체 원인의 20%에서 일어나는 현상 (vip 20% 가 매출 80%)
+ Brooks의 법칙 : 지연되는 프로젝트에 인력을 투입하면 더 늦어진다.

+ 살충제 패러독스 (Pesticide Paradox) : 동일 테스트 케이스로 동일 테스트 반복시 더이상 결함이 발견되지 않는 현상

+ 오류 - 부재의 궤변 : 결함을 모두 제거해도 사용자 요구사항을 만족시키지 못하면 품질이 높다고 할 수 없음

+ 테스트 커버리지 : 구문 / 결정 / 조건 / 조건결정 / 변경조건결정 / 다중조건

+ 테스트 오라클 : true(모든 입력값) / 일관성(입력출력) / 샘플링 / Heuristic(나머지는 추정)

+ 화이트박스 : 코드의 논리적 모든 경로를 오픈, 문장 / 분기 / 조건 / 분기조건
  - 기초 경로 검사 : 제어 흐름
  - 제어 구조 검사
    - 조건검사
    - 루프검사
    - 데이터흐름검사

+ 블랙박스 : 프로그램의 구조를 고려하지 않고 입력과 출력만
  - 동치 분할 검사 : 입력 자료에 초점을 맞춰 케이스를 만들고 검사
  - 원인-효과 그래프 검사 : 입출력영향
  - 오류 예측 검사 : 경험
  - 비교 검사 : 여러 버전
  - 경계값 분석
+ 테스트 하네스 도구
  - 테스트 드라이버 : 상향식 테스트
  - 테스트 스텁 : 하향식 테스트
  - 테스트 슈트 (응용 분야) / 테스트 케이스 / 테스트 스크립트(명령어) / 목 오브젝트 (미리 입력)



### 소스 코드 최적화

+ 소스 코드 품질 분석 도구 
  - 정적 분석 도구 : 소스코드검증, 코드리뷰, 리버스엔지니어링
    - pmd : 소스 코드에 대한 미사용 변수, 최적화 안된 코드 등 결함을 유발할 수 있는 코드를 검사
    - cppcheck : C/C++ 코드에 대한 메모리 누수 및 오버플로우 분석
    - SonarQube : 중복 코드나 복잡도 높은 코딩 설계 등을 분석하는 소스 분석 통합 플랫폼
    - ccm : 다양한 언어의 코드 복잡도를 분석
    - checkstyle : 자바 코드에 대해 소스코드 표준을 따르고 있는지 검사
    - cobertura : 자바 코드의 복잡도 분석 및 테스트 커버리지 측정
  - 동적 분석 도구 : 디버깅, 스트레스테스트, 모의해킹
    - Avalanche : valrind 프레임워크 및 stp 기반, 프로그램 결함 및 취약점 분석
    - valgrind : 프로그램 내에 존재하는 메모리 및 쓰레드 결함 분석
    - valMeter



### 인터페이스 구현

+ 검증 도구
  - Watir : Ruby 사용
  - xUnit : Java, C++ 등 다양한 언어를 지원하는 단위 테스트 프레임워크
  - FitNesse : 웹 기반 테스트
  - STAF : 서비스 호출 및 컴포넌트 재사용 등 환경을 지원함, 데몬
  - NTAF : 협업 기능과 재사용 및 확장성을 통합한 네이버의 테스트 자동화 프레임워크
  - Selenium : 다양한 브라우저 및 개발 언어를 지원



### 알고리즘

+ 설계 기법
  - 분할 정복법 : 과제 분할, 퀵 정렬, 병합 정렬 알고리즘
  - 동적 계획법 : 쉬운 문제부터, 플로이드 알고리즘, 피보나치 수열 알고리즘
  - 탐욕법 : 크루스칼, 다익스트라
  - 퇴각 검색법 : N-Queen
  - 분기 한정법 : 최적 우선 탐색 알고리즘
  - 근사 해법 : NP-Hard, 근사 알고리즘
+ 시간 복잡도 : 연산, 소요시간 계산
  - Big-0 표기법 : O(Nlog2n) 퀵정렬, 병합정렬
  - 0(1) : 상수형 복잡도, 해시 함수, 비례하지 않는, 항상 일정한
  - 0(n) : 선형 복잡도, 정비례하는, 순차 탐색
+ 해싱 함수 : 인덱스, 직접 접근 파일, 오버플로 위험, 메모리 많이 사용
  - 제산 방법(Division) : 나머지 연산자
  - 중간 제곱 방법(Mid-Square) : 키값을 제곱
  - 중첩 방법(폴딩) : 나누기, XOR(배타적 논리합)
  - 기수 변환 방법 : 분포
  - 동의어 : 충돌이 일어난 레코드



### 자료 구조

+ 선형 자료 구조 : 리스트, 스택, 큐, 테크
+ 비선형 구조 : 트리, 그래프

+ 정렬
  - 삽입 정렬 : 두 번째 값을 키값으로 지정 후 비교 -> 세번째 값을 키값으로 지정 후 비교 ---
  - 버블 정렬 : 두 개씩 정렬, 1회전 마다 제일 큰 값이 뒤로
  - 선택 정렬 : O(n^2), 시간이 오래 걸림, 1회전 마다 제일 작은 값이 앞으로
  - 병합 정렬 : O(nlog_2n), 두 개의 키를 한 쌍으로
  - 퀵 정렬 : O(nlog_2n), 최악 : O(n^2), 부분 교환 정렬법, 하나의 파일을 부분적으로 나눠가며 정렬
  - 힙 정렬 (Heap) : O(nlog_2n), 최악 : O(nlog_2n), 전이진 트리
+ 검색
  - 이분 검색(이진 검색) : 순차 정렬 필수, 효율성 높음 
  - 선형 검색(순차 검색) : 비효율적, (n+1)/2
+ 인덱스
  - 색인 순차 파일의 구성 : 기본 구성, 색인 영역 (트랙, 실린더, 마스터 인덱스), 오버플로 영역 (실린더 오버플로, 독립 오버플로)



### 데이터베이스

+ 스키마

  - 외부 스키마 : 접근 정의
  - 개념 스키마 : 데이터 접근 권한, 무결성 규칙
  - 내부 스키마 : 실제 저장 방법

+ 데이터베이스 모델

  - 데이터 구조, 연산, 제약 조건
  - 개념적 모델 : E-R 다이어그램 (개체-사각형, 관계-마름모, 속성-타원, 연결-실선)
  - 논리적 모델 : 계층형 (트리구조), 네트워크(망)형 (그래프 구조), 관계형 (table의 집합), 객체지향형

+ Key의 종류

  - 슈퍼키 : 두 개 이상의 속성으로 구성된 키 또는 혼합키 (학번+나이, 주민번호+이름)
  - 후보키 (기본키가 될 수 있는 후보들, 유일성과 최소성 만족), 기본키 (후보키들 중에서 선택), 대체키 (남은 후보키)
  - 외래키 : 다른 테이블의 기본키로 사용되는 속성 (학생 테이블의 학번은 참조키, 수강 테이블의 학번은 외래키)

+ 무결성

  - 개체 무결성 : 기본키의 값은 null 이나 중복 값을 가질수 없음
  - 참조 무결성 : 외래키를 변경하려면 참조키도 변경해야함
  - 도메인 무결성 : 릴레이션 중 하나의 속성은 반드시 원자값이어야함

+ 데이터베이스 설계

  - 요구조건 분석
  - 개념적 설계
  - 논리적 설계 (데이터 모델링)
    - 개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계
    - 스키마의 평가 및 정제
    - 개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 매핑 및 모델화
    - 트랜잭션 인터페이스 설계
  - 물리적 설계 (데이터 구조화)
    - 논리적 구조로 표현된 데이터를 물리적 구조의 데이터로 변환
    - 데이터베이스 파일의 저장 구조 및 엑세스 경로 설정
    - 저장 레코드의 양식 설계, 레코드 집중의 분석 및 설계, 접근 경로 설계
    - 성능에 중대한 영향을 미침

+ 데이터베이스 정규화 : 도부이결다조

+ 데이터베이스 반정규화 기법

  - 테이블 반정규화 기법 : 테이블 병합, 분할, 추가
    - 테이블 병합 : 1:1, 1:다, 슈퍼:서브
    - 테이블 분할 : 파티셔닝, 분산기법, 분할키 기준 분할, 범위, 해시, 조합 (Composite), 목록, 라운드-로빈
    - 테이블 추가 : 집중이부진

  - 컬럼 반정규화 기법 : 중복 컬럼 추가, 파생, 이력 테이블, PK(Primary Key)
  - 관계 반정규화 기법 : 중복 관계 추가, 데이터 무결성을 깨뜨리지 않고도 성능 향상이 가능함



### 관계 대수와 관계 해석

+ 관계 대수 : 절차적 언어, 연산의 집합

+ 순수 관계 연산자

  - Select(합) : 튜플 집합 검색, 수평적 연산
    - 시그마학과='전자과'(학생) : 학생 릴레이션에서 학과가 전자과인 학생의 튜플을 반환

  - Project(파이) : 속성 집합 검색, 수직적 연산
  - Join(리본) : 두 릴레이션의 공통 속성을 연결해 새로운 릴레이션을 반환
  - Division(나누기 기호) : R÷S는 S에 포함된 튜플을 모두 가지는 R의 튜플 중에, S에 포함된 애트리뷰트를 제거하고 반환

+ 집합 연산자 : 합집합, 교집합, 차집합, 교차곱 (Cartesian Product, 속성은 더하고 튜플은 곱하고)



### 트랜잭션

+ 특성
  - 원자성 (Atomicity) : 트랜잭션의 연산은 모두 실행되거나 모두 실행되지 않아야 함 (Commit / Rollback)
  - 일관성 (Consistency) : 고정 요소는 트랜잭션 수행 전과 후가 같아야 함
  - 격리성 (Isolation) : 병행 실행되는 경우 하나의 트랜잭션 실행 중에 다른 연산이 끼어들수 없음
  - 영속성 (Durability) : 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함
+ 병행 제어
  - 로킹 : 단계별 로킹, 2단계 로킹 (확장, 축소)

    - 병행 제어를 위해 트랜잭션이 접근하고자 하는 데이터를 잠가 다른 트랜잭션이 접근하지 못하도록 하는 병행 제어 기법
    - 로킹 단위 : 필드, 레코드, 테이블, 파일, 데이터베이스 전체

    - 로킹 단위 크면 : 병행수준, 데이터베이스 공유도, 오버헤드 저하, 제어기법 간단해 관리 수월
    - 로킹 단위 작으면 : 병행수준, 데이터베이스 공유도, 오버헤드 증가, 제어기법 까다러워 관리 복잡



### 운영체제

+ 제어 프로그램 : 감시, 작업 제어, 데이터 관리
+ 처리 프로그램 : 언어 번역, 서비스, 문제 프로그램
+ 스레드
  - 프로세스 내의 작업 단위, 한 개의 프로세스는 여러 개의 스레드를 가짐
  - 장점 : 하드웨어 운영체제 성능과 처리율 향상, 응용프로그램 응답시간 단축, 실행 환경을 공유해 메모리 낭비 감소
  - 커널 스레드 : 운영체제 커널에 의해 운용, 구현 쉽고 속도 느림
  - 사용자 스레드 : 사용자가 만든 라이브러리를 사용해 스레드 운용, 구현 어렵고 속도 빠름
+ 프로세스 상태의 종류 : new, ready, running, exit, block, deadlock, terminated, submit, hold, pending
+ 교착상태 (Deadlock)
  - 점유 및 대기 (Hold and wait)
  - 상호배제 (Mutual exclusion)
  - 비선점 (Non-preemption)
  - 환형 대기 (Circular wait)
+ 교착상태 해결 방법
  - 예방
  - 회피 (Avoidance) : 은행가 알고리즘
  - 발견 (Detection) : 자원 할당 그래프
  - 회복 (Recovery) : 자원 선점, 프로세스 종료
+ 프로세스 스케줄링
  - 비선점 : FIFO, SJF, HRN, 우선 순위
  - 선점 : 라운드로빈, SRT, 다단계큐, 다단계피드백큐
+ 기억 장치 관리
  - OPT (가장 이상적)
  - FIFO
  - LRU (Least Recently Used) : 최근에 가장 적게 쓴
  - LFU (Least Frequently Used) : 최근에 가장 적게 참조된
  - NUR (Not Used Recently) : 최근에 사용 안한
  - SCR (Second Chance Replacement) : FIFO 단점을 보완
+ 페이징 기법 : 맵테이블, 동일한 크기로 나눔
  - 페이지 크기가 작은 경우 : 기억장소 이용 효율적, 입출력 시간 증가
+ 디스크 스케줄링
  - 종류 : FCFS, SSTF (Shortest Seek Time First), SCAN (왕복), C-SCAN (밖->안), 에센바흐 (한 회전 동안 처리)
+ 파일 디스크립터
  - 파일 제어 블록, 파일의 생성 시간, 수정 시간
+ 분산 운영체제
  - 상호 연결 방법 
    - 하이퍼 큐브 : 10개 이상의 프로세서를 병렬로 동작, n개의 프로세서 = 2^n
    - 시분할 공유 버스, 크로스바 교환 행렬, 다중 포트 메모리



### UNIX

+ 특징 : 시분할, 개방형, 트리구조, 멀티유저, C언어
+ 구성
  - 커널 (Kernel) : 프로세스, 메모리, 입출력 관리를 수행, 컴퓨터 부팅시 주기억 장치에 적재된 후 상주
  - 쉘 (Shell) : 시스템과 사용자 간의 인터페이스, 명령어 해석기, 주기억 장치에 상주하지 않고 파일 형태로 존재하며 보조 기억 장치에서 교체 처리가 가능
  - 유틸리티

+ 파일 관련 명령어 : cat (파일의 내용을 메모장처럼 화면에 표시), chmod (사용 권한 지정), chown (소유자 변경), fork (새로운 프로세스 생성)
+ 로그 파일 명령어
  - wtmp : 사용자 로그인 로그아웃 정보 (last 명령어로 확인 가능)
  - lastlog : 사용자별 마지막 로그인 시간 등 정보 저장
  - message : 시스템 사용에 관한 모든 로그
+ 환경 변수 : 쉘이 값을 전달해주는 역할, 컴퓨터에 프로세스가 동작하는 방식에 영향을 미침, 대문자























