# 44 C언어

## 44.1 C언어의 기초

+ 1972 벨 연구소의 데니스 리치에 의해 개발
+ 컴파일러 방식, 포인터에 의한 번지 연산
+ 기본 자료형
  - 정수형 : int (2byte) , long (4byte)
  - 실수형 : float (4byte), double (8byte)
  - 문자형 : char (1byte)
+ 기억 클래스 : 자동 변수, 레지스터 변수, 정적 변수, 외부 변수
+ 입출력 함수 - 표준 입출력 함수
  - scanf() : 표준 입력 함수
  - printf() : 표준 출력 함수
  - getchar() : 문자 입력 함수
  - putchar() : 문자 출력 함수
  - gets() : 문자열 입력 함수, string
  - puts() : 문자열 출력 함수
+ 입출력 함수 - 변환 문자 (출력 형식 지정 문자)
  - %d : 10진 정수, decimal
  - %o : 8진 정수, octet
  - %x : 16진 정수, hexa
  - %f : 실수형, %e : 지수형, %c : 문자, %s : 문자열
+ 문자열 처리 함수
  - strcat(n1, n2) : 문자열 연결 함수
  - strrev() : 거꾸로 변환
+ 이스케이프 시퀀스 : ＼n (다음 줄), ＼r (carriage return), ＼t (tab), ＼b (뒤로 한칸), ＼f (한페이지)
+ 변수명 작성 규칙 : 영문 대소문자 + 숫자 + _ 혼용 가능, 첫 글자는 영문자나 _로 시작, 대소문자 구분, 공백 X
+ 포인터 변수 : 주소값 저장, 메모리 크기 동일, *연산자
+ 표준 라이브러리 함수 : stdio.h
  - 함수 종류 : atoi (문자->정수), atol (문자->log), itoa (숫자->문자), ceil, floor, rand, div

## 44.2 C언어 연산자

+ 단항 연산자 : ! (부정), ~ (1의 보수), & (변수의 주소), * (변수의 내용), sizeof (Byte 단위로 크기를 구함)

+ 산술 연산자

+ 시프트 연산자 : <<, >> (a=1, a<<1 이면 00000001에서 이동 00000010)

+ 비트 연산자 : 논리곱, 논리합, 배타적논리합(^)

+ 삼항 연산자 : 조건식 ? 참일때 : 거짓일때

+ 연산자 우선 순위  : 단항 산술 비트 관계 논리 비트논리 조건 할당

+ 0이 아닌 모든 값은 1

+ ```c
  int arr[2][3]={1,2,3,4,5,6}
  int (*p)[3]=NULL;
  p=arr;
  printf("%d ", *(p[0]+1) + *(p[1]+2));
  printf("%d", *(*(p+1)+0) + *(*(p+1)+1));
  
  // [0] 1, 2, 3 [1] 4, 5, 6
  // arr[0]번에 인덱스[1] = 2
  // arr[1]번에 인덱스[2] = 6
  // 2 + 6 = 8
  
  int n = 4;
  int* pt = NULL;
  pt=&n; // pt는 변수 n의 주소값
  // &n = 변수 n의 주소값
  // *pt = pt가 가리키는 주소에 저장된 값 = 변수 n
  // *&pt = *(pt의 주소값) = 변수 n의 주소값
  ```

<br>

<br>

<br>

# 45 Java 언어

## 45.1 Java 언어의 기초

+ 객체지향 언어
+ 추상화, 상속화, 다형성
+ Carbage Collector : 불필요한 메모리 정리
+ 기본 자료형
  - 정수형 : byte (1byte), short (2byte), int (4byte), long (8byte)
  - 실수형 : float (4byte), double (8byte)
  - 문자형 : char (2byte)
  - 논리형 : boolean (1byte)
+ 접근 제어자 : public, private (상속 관계 객체), default, protected (현재 객체 내)
+ 출력 함수
  - System.out.print() : 괄호 안을 출력하고 줄바꿈 안함
  - System.out.printin() : 출력 후 줄바꿈
  - System.out.printf() : 변환 문자를 사용해 출력
+ 변환 문자 (출력 형식 지정 문자) : C언어와 동일
+ 변수명 작성 규칙 : C언어와 동일 + $ 사용
+ 오버로딩 : 한 클래스 내에서 같은 메소드 이름 사용
+ 오버라이딩 : 상속 관계의 상위 클래스에서 정의한 메소드를 하위 클래스에서 재정의

<br>

<br>

<br>

# 46 제어문

## 46.1 조건문

+ if 문 : if...else 문 / if...else if...else 문 / 삼항 연산자
+ switch...case 문

## 46.2 반복문

+ while
+ do...while
+ for

<br>

<br>

<br>

# 47 스크립트 언어와 Python

## 47.1 스크립트 언어

+ 스크립트 언어 : 소스 코드를 컴파일 과정을 거치지 않고 실행할 수 있는 언어, 인터프리터 언어
+ 서버 : ASP (윈도우), JSP, PHP (리눅스, 유닉스), 파이썬
+ 클라이언트 : Javascript, VBScript

## 47.2 파이썬

+ 1991년 귀도 반 로섬이 개발
+ 인터프리터식, 객체지향적, 동적 타이핑, 쉬움
+ 변수명 작성 규칙 : 영문 대소문자 + 숫자 + _  사용 가능, C언어와 동일
+ python 조건문 if, elif, else
+ 데이터 타입
  - 시퀀스 : 리스트 (순서 있고 가변), 튜플 (순서 있고 불변)
  - 세트 : 순서 없고 중복X
  - 맵 : 딕셔너리 (순서 없고 키-밸류)
+ print() : 자동으로 개행
+ 문자열 출력

```python
string = 'Python Good' // 공백 포함

s = string[1]
print(s) // y

s = string[-1]
print(s) // d

s = string[:] // 모두 출력
print(s) // Python Good

s = string[7:] // x번째 인덱스부터
print(s) // Good

s = string[:3] // y-1번째 인덱스까지
print(s) // Pyt

s = string[1:3]
print(s) // yt

s = string[1:8:2]
print(s) // yhnG
```

<br>

<br>

<br>

# 48 운영체제와 프로세스

## 48.1 운영체제

+ 운영체제 : 사용자와 하드웨어 간의 인터페이스로서 동작
+ 운영 방식 : 일괄 처리, 다중 프로그래밍, 시분할 시스템, 다중 처리, 실시간
+ 제어 프로그램 : 감시, 작업 제어, 데이터 관리
+ 처리 프로그램 : 언어 번역, 서비스, 문제 프로그램

## 48.2 프로세스 관리

+ 프로세스 : 실행 중인 프로그램
+ PCB (Process Control Block) : 운영체제가 프로세스를 관리하기 위해 정보를 저장해 놓은 곳
+ 스레드 : 프로세스 내의 작업 단위, 한 개의 프로세스는 여러 개의 스레드를 가짐
+ 프로세스 상태의 종류 : new, ready, running, exit, block
+ 병행 프로세스 : 임계 영역 (충돌 방지), 상호배제 (다른 프로세스 배제), 동기화 기법 (다익스트라, 세마포어, 수신호, 모니터)
+ 교착상태 (Deadlock) : 점유 및 대기, 상호배제, 비선점, 환형 대기
+ 교착상태 해결 방법 : 예방, 회피 (은행가 알고리즘), 발견, 회복

## 48.3 프로세스 스케줄링

+ 비선점 : 다른 프로세스가 끝날때까지 기다리는 방식

  - FCFS(FIFO) : 선입선출
    - 실행 순서 : 1 - 2 - 3
    - 대기 시간 : 1 (0), 2 (10), 3 (40)
    - 반환 시간 : 1 (13), 2 (45), 3 (50)

  | 작업 | 도착 시간 | 실행 시간 |
  | :--: | :-------: | :-------: |
  |  P1  |     0     |    13     |
  |  P2  |     3     |    35     |
  |  P3  |     8     |    10     |

  - SJF (Shortest Job First) : 실행 시간이 가장 짧은 프로세스
    - 실행 순서 : 2 - 1 - 4 - 3
    - 대기 시간 : 2 (0), 1 (3), 4 (9), 3 (16)
    - 반환 시간 : 2 (3), 1 (9), 4 (16), 3 (24)

  | 작업 | 실행 시간 |
  | :--: | :-------: |
  |  P1  |     6     |
  |  P2  |     3     |
  |  P3  |     8     |
  |  P4  |     7     |

  - HRN (Highest Response-ratio Next) : 실행 시간과 기다린 시간으로 우선순위 결정
    - 계산식 : (대기 시간 + 서비스를 받을 시간) / 서비스를 받을 시간

  | 작업 | 대기 시간 | 서비스 실행 시간 |
  | :--: | :-------: | :--------------: |
  |  P1  |     5     |        20        |
  |  P2  |    40     |        20        |
  |  P3  |    15     |        45        |
  |  P4  |    20     |        20        |

  - 우선 순위 : 우선 순위가 가장 높은 프로세스, 무한 정지 가능성을 에이징으로 해결

+ 선점 : 우선 순위가 높은 다른 프로세스가 빼앗을 수 있음, 타이머 클럭
  - RR (Round Robin) : 주어진 시간 할당량 안에 작업을 마치지 않으면 뒤로 배치
  - SRT (Shortest Remaining Time) : 실행시간 추정치가 가장 작은 작업
  - 다단계큐 : 단계별 준비 상태 큐
  - 다단계 피드백큐 

## 48.4 기억 장치 관리

+ 반입 전략 : 보조 기억 장치의 데이터를 주기억 장치로 언제 가져올 것인지 결정하는 전략
+ 배치 전략 : 보조 기억 장치의 데이터를 주기억 장치 내의 어디로 가져올 것인지 결정하는 전략
  - 최초 적합, 최상 적합, 최악 적합
+ 교체 전략
  - OPT (가장 이상적)
  - FIFO
  - LRU (Least Recently Used) : 최근에 가장 적게 쓴
  - LFU (Least Frequently Used) : 최근에 가장 적게 참조된
  - NUR (Not Used Recently) : 최근에 사용 안한
  - SCR (Second Chance Replacement) : FIFO 단점을 보완
+ 가상 기억 장치 구현 기법 : 주기억 장치의 부족한 용량을 해결하기 위해 보조 기억 장치를 주기억 장치처럼 사용
  - 페이징 기법 : 맵테이블, 동일한 크기로 나눔
  - 세그멘테이션 기법 : 다양한 크기로 나눔
+ 구역성 : 시간 구역성, 공간 구역성
+ 워킹 셋 : 자주 참조하는 페이지들의 집합
+ 스레싱 : 프로세스 수행보다 이동에 소요되는 시간이 더 커지는 현상
+ 페이지 부재 : 참조할 페이지가 주기억 장치에 없는 현상
  - 페이지 참조 순서 : 1,2,3,1,2,4,1,2,5
  - 프레임 : 3개
  - 교체 알고리즘 : FIFO
  - 페이지 결함 : 7번

## 48.5 디스크 스케줄링

+ 디스크의 여러 곳에 저장된 데이터를 액세스 하기 위해 헤드의 이동 경로를 결정하는 기법
+ 종류 : FCFS, SSTF (Shortest Seek Time First), SCAN (왕복), C-SCAN (밖->안), 에센바흐 (한 회전 동안 처리)

## 48.6 정보 관리

+ 파일 시스템 : 연관된 데이터들의 집합
+ 파일 디스크립터 (File Descriptor) : 파일 제어 블록, 파일의 생성 시간, 수정 시간

## 48.7 분산 운영체제

+ 다중 처리기 : 하나의 시스템에 두 개 이상의 프로세서를 가지고 여러 개의 작업을 처리하는 장치
+ 상호 연결 방법 
  - 하이퍼 큐브 : 10개 이상의 프로세서를 병렬로 동작, n개의 프로세서 = 2^n
  - 시분할 공유 버스, 크로스바 교환 행렬, 다중 포트 메모리
+ 다중 처리기 운영체제의 구조 : 주종처리기, 분리수행, 대칭적
+ 약결합 / 강결합

## 48.8 UNIX

+ 특징 : 시분할, 개방형, 트리구조, 멀티유저, C언어
+ 구성 : 커널 (프로세스, 메모리 관리), 쉘 (인터페이스), 유틸리티
+ 구조 : 부트 블록, 슈퍼 블록, I-node 블록 (파일 디스크립터), 데이터 블록
+ 파일 관련 명령어 : cat (파일의 내용을 메모장처럼 화면에 표시), chmod (사용 권한 지정), chown (소유자 변경), fork (새로운 프로세스 생성)
+ 로그 파일 명령어
  - wtmp : 사용자 로그인 로그아웃 정보 (last 명령어로 확인 가능)
  - lastlog : 사용자별 마지막 로그인 시간 등 정보 저장
  - message : 시스템 사용에 관한 모든 로그
+ 환경 변수 : 쉘이 값을 전달해주는 역할, 컴퓨터에 프로세스가 동작하는 방식에 영향을 미침, 대문자
+ BASH Shell : LINUX 표준 쉘
+ 파일 생성 권한 : 666

## 48.9 OSI 7계층

+ Open Systems Interconnection : 프로토콜을 기능별로 나눈 것
+ 응표세전네데물!
+ 물리 계층 : 프로토콜 (X.21, RS-232C, V.24)
+ 데이터 링크 계층 : 인접한 두개의 통신 시스템, 프로토콜 (HDLC, PPP, LLC, LAPB, LAPD, ADCCP)
+ 네트워크 계층 : 경로 설정, IP패킷 (X.25, ICMP, IGMP)
+ 전송 계층 : 신뢰할 수 있는 통신, (TCP, UDP)
+ 세션 계층 (통신 방식), 표현 계층 (암호화 등 데이터 변환)
+ 응용 계층 : HTTP, POP3, SMTP, DNS, FTP, Telnet

## 48.10 오류 제어 방식

+ 자동 반복 요청
  - Stop-and-Wait ARQ : 송신 확인 - 수신 응답, ACK - NAK
  - 연속 ARQ : 일단 다보내고 오류 생기면 거기서부터 다시 보냄 / 선택적 : 오류 발생 블록만
  - 적응적 ARQ : 채널의 상태에 따라 동적으로 변경

## 48.11 TCP/IP 프로토콜

+ 인터넷 기본 프로토콜
+ 응용 계층 - 전송 계층 - 인터넷 계층 - 링크 계층
+ TCP : 전송 계층, 신뢰성 (UDP)
+ IP : 네트워크 계층, 비신뢰성
  - ICMP (Internet Control Message Protocol) : 오류 보고와 수정 보완, 에코 메세지
  - IGMP (Internet Group Management Protocol) : 멀티캐스트
  - ARP (Address Resolution Protocol) : IP 주소를 이용해 MAC 주소를 찾음, 
  - RARP (Reverse ARP) : MAC 주소로 IP 주소를 찾음, 
+ IP 주소
  - IPv4 : 32비트
  - IPv6 : 128비트, 인증 보안 기능, 확장 헤더, 유니캐스트, 애니캐스트, 멀티캐스트
  - 주소 체계 : 클래스 A (0~127), 클래스 B (128~191), 클래스 C (192~223)
  - 듀얼 스택 / 터널링 / 헤더 변환
+ 서브넷 마스크 : 203.241.132.82/27 -> 호스트 ID 5개 -> 11100000 -> 255.255.255.224
+ IEEE 802 : 이더넷, 무선 통신 기술에 대한 물리적, 데이트 링크 계층 사양을 다루는 네트워크 표준 집합
  - 802.4 : 토큰 버스
  - 802.5 : 토큰 링
  - 802.8 : 고속 이더넷
  - 802.11 :무선 랜
  - 802.15 : 블루투스
+ CSMA/CA : 무선 / 충돌 회피
+ CSMA/CD : 유선 / 신호가 흐르는지, 데이터가 흐르는지, 충돌이 발생하는지 

























